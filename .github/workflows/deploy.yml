# GitHub Actions workflow to deploy a Proxy LAMP Stack application on AWS EC2 with Load Balancer

name: Deploy Proxy LAMP Stack with Load Balancer

# Event triggers
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Environment variables shared across all jobs
env:
  AWS_REGION: eu-central-1
  TF_VERSION: 1.5.0
  DEPLOYMENT_BUCKET: proxy-lamp-deployment-cletusmangu-1749764715

jobs:
  terraform:
    name: 'Terraform Infrastructure'
    runs-on: ubuntu-latest
    outputs:
      load_balancer_dns: ${{ steps.terraform-output.outputs.load_balancer_dns }}
      autoscaling_group_name: ${{ steps.terraform-output.outputs.autoscaling_group_name }}
    
    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Clean Terraform State
      run: |
        echo "Cleaning up potential state issues..."
        rm -rf .terraform/
        rm -f .terraform.lock.hcl
        terraform fmt -recursive .
        echo "‚úÖ Terraform files formatted"

    - name: Terraform Init
      run: |
        echo "Initializing Terraform..."
        terraform init -reconfigure
        echo "‚úÖ Terraform initialized"

    - name: Terraform Validate
      run: |
        echo "Validating Terraform configuration..."
        terraform validate
        echo "‚úÖ Terraform configuration is valid"

    - name: Terraform Plan
      if: github.event_name == 'pull_request'
      run: |
        terraform plan \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -no-color
      continue-on-error: true

    - name: Terraform Apply
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        terraform apply \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -auto-approve

    - name: Get Terraform Outputs
      if: github.ref == 'refs/heads/main'
      id: terraform-output
      run: |
        echo "load_balancer_dns=$(terraform output -raw load_balancer_dns)" >> $GITHUB_OUTPUT
        echo "autoscaling_group_name=$(terraform output -raw autoscaling_group_name)" >> $GITHUB_OUTPUT

  deploy:
    name: 'Deploy Application to Load Balanced Infrastructure'
    runs-on: ubuntu-latest
    needs: terraform
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Infrastructure to be Ready
      run: |
        echo "Waiting for Auto Scaling Group instances to be ready..."
        sleep 180

    - name: Pre-deployment Verification
      run: |
        echo "=== PRE-DEPLOYMENT VERIFICATION ==="
        
        if [ ! -d "app" ]; then
            echo "‚ùå App directory not found!"
            exit 1
        fi
        
        cd app
        echo "Files in app directory:"
        ls -la
        
        REQUIRED_FILES=("index.php" "config.php" "add.php" "delete.php" "health.php" "styles.css")
        MISSING_FILES=()
        
        for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
                MISSING_FILES+=("$file")
            fi
        done
        
        if [ ${#MISSING_FILES[@]} -ne 0 ]; then
            echo "‚ùå Missing required files: ${MISSING_FILES[*]}"
            exit 1
        fi
        
        echo "‚úÖ All required files are present"
        
        echo "Checking PHP syntax..."
        for phpfile in *.php; do
            if [ -f "$phpfile" ]; then
                if ! php -l "$phpfile" >/dev/null 2>&1; then
                    echo "‚ùå PHP syntax error in $phpfile"
                    php -l "$phpfile"
                    exit 1
                fi
            fi
        done
        
        echo "‚úÖ All PHP files have valid syntax"
        
        if [ -f "styles.css" ]; then
            echo "‚úÖ CSS file (styles.css) found"
            if grep -q "body\s*{" styles.css && grep -q "}" styles.css; then
                echo "‚úÖ CSS file appears to have valid structure"
            else
                echo "‚ö†Ô∏è CSS file may have structural issues"
            fi
        else
            echo "‚ùå CSS file (styles.css) not found"
            exit 1
        fi
        
        echo "‚úÖ Pre-deployment verification completed successfully"
        cd ..

    - name: Get Instance IPs from Auto Scaling Group
      id: get-instances
      env:
        ASG_NAME: ${{ needs.terraform.outputs.autoscaling_group_name }}
      run: |
        echo "Getting instance IPs from Auto Scaling Group: $ASG_NAME"
        
        echo "=== Waiting for instances to appear in ASG ==="
        for attempt in {1..30}; do
          ALL_INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --query 'AutoScalingGroups[0].Instances[*].InstanceId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$ALL_INSTANCE_IDS" ] && [ "$ALL_INSTANCE_IDS" != "None" ]; then
            echo "‚úÖ Found instances in ASG: $ALL_INSTANCE_IDS"
            break
          else
            echo "‚è≥ Waiting for instances in ASG... attempt $attempt/30"
            sleep 30
          fi
          
          if [ $attempt -eq 30 ]; then
            echo "‚ùå No instances found in ASG after 15 minutes"
            exit 1
          fi
        done
        
        echo "=== Waiting for instances to be in running state ==="
        RUNNING_INSTANCES=""
        for attempt in {1..20}; do
          RUNNING_INSTANCES=""
          for INSTANCE_ID in $ALL_INSTANCE_IDS; do
            INSTANCE_STATE=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text 2>/dev/null || echo "unknown")
            
            echo "Instance $INSTANCE_ID state: $INSTANCE_STATE"
            
            if [ "$INSTANCE_STATE" = "running" ]; then
              RUNNING_INSTANCES="$RUNNING_INSTANCES $INSTANCE_ID"
            fi
          done
          
          RUNNING_INSTANCES=$(echo "$RUNNING_INSTANCES" | xargs)
          
          if [ -n "$RUNNING_INSTANCES" ]; then
            echo "‚úÖ Found running instances: $RUNNING_INSTANCES"
            break
          else
            echo "‚è≥ Waiting for running instances... attempt $attempt/20"
            sleep 30
          fi
          
          if [ $attempt -eq 20 ]; then
            echo "‚ùå No running instances found after 10 minutes"
            exit 1
          fi
        done
        
        echo "=== Getting IP addresses for running instances ==="
        INSTANCE_IPS_RAW=$(aws ec2 describe-instances \
          --instance-ids $RUNNING_INSTANCES \
          --query 'Reservations[].Instances[?State.Name==`running`].PublicIpAddress' \
          --output text)
        
        INSTANCE_IPS=$(echo "$INSTANCE_IPS_RAW" | tr '\n\t' ' ' | tr -s ' ' | xargs)
        
        echo "Public IPs: $INSTANCE_IPS"
        
        if [ -z "$INSTANCE_IPS" ]; then
          echo "‚ùå No IP addresses found for running instances!"
          exit 1
        fi
        
        echo "INSTANCE_IPS=$INSTANCE_IPS" >> $GITHUB_ENV
        echo "‚úÖ Found instances with IPs: $INSTANCE_IPS"

    - name: Deploy Application to All Instances
      env:
        PRIVATE_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        echo "$PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem
        
        echo "Instance IPs to deploy to: $INSTANCE_IPS"
        
        if [ -z "$INSTANCE_IPS" ]; then
          echo "‚ùå No instance IPs available for deployment"
          exit 1
        fi
        
        IP_COUNT=$(echo $INSTANCE_IPS | wc -w)
        echo "Number of IPs to deploy to: $IP_COUNT"
        
        echo "=== Checking available files for deployment ==="
        if [ ! -d "app" ]; then
          echo "‚ùå App directory not found!"
          exit 1
        fi
        
        ls -la app/
        
        SUCCESS_COUNT=0
        TOTAL_COUNT=0
        
        for INSTANCE_IP in $INSTANCE_IPS; do
          echo "===================="
          echo "Deploying to instance: $INSTANCE_IP"
          echo "===================="
          
          TOTAL_COUNT=$((TOTAL_COUNT + 1))
          
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
            echo "Skipping empty or invalid IP: $INSTANCE_IP"
            continue
          fi
          
          echo "Waiting for SSH connection to $INSTANCE_IP..."
          SSH_SUCCESS=false
          
          for i in {1..20}; do
            if timeout 15 ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ubuntu@$INSTANCE_IP "echo 'SSH connection successful'" 2>/dev/null; then
              echo "‚úÖ SSH connection established to $INSTANCE_IP!"
              SSH_SUCCESS=true
              break
            fi
            echo "Waiting for SSH... attempt $i/20"
            sleep 30
          done
          
          if [ "$SSH_SUCCESS" = false ]; then
            echo "‚ùå Failed to establish SSH connection to $INSTANCE_IP after 10 minutes"
            continue
          fi
          
          echo "Checking Apache status on $INSTANCE_IP..."
          APACHE_STATUS=$(ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
            if systemctl is-active --quiet apache2; then
              echo 'running'
            else
              echo 'not_running'
            fi
          " 2>/dev/null || echo "unknown")
          
          if [ "$APACHE_STATUS" != "running" ]; then
            echo "‚ö†Ô∏è Apache is not running on $INSTANCE_IP - attempting to fix..."
            
            ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
              set -e
              echo 'Fixing Apache configuration...'
              sudo a2enmod remoteip headers rewrite ssl status 2>/dev/null || echo 'Modules already enabled'
              if ! sudo apache2ctl configtest 2>/dev/null; then
                echo 'Apache configuration has errors - disabling problematic configs'
                sudo a2disconf load-balancer 2>/dev/null || true
              fi
              sudo systemctl restart apache2
              sleep 3
              if systemctl is-active --quiet apache2; then
                echo '‚úÖ Apache is now running'
              else
                echo '‚ùå Apache failed to start'
                sudo systemctl status apache2 --no-pager || true
                exit 1
              fi
            " || {
              echo "‚ùå Failed to fix Apache on $INSTANCE_IP"
              continue
            }
          else
            echo "‚úÖ Apache is already running on $INSTANCE_IP"
          fi
          
          echo "Testing Apache HTTP response on $INSTANCE_IP..."
          HTTP_SUCCESS=false
          
          for attempt in {1..10}; do
            if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "curl -s -f http://localhost/ > /dev/null" 2>/dev/null; then
              echo "‚úÖ Apache is responding on $INSTANCE_IP"
              HTTP_SUCCESS=true
              break
            else
              echo "‚è≥ Waiting for Apache to respond... attempt $attempt/10"
              sleep 10
            fi
          done
          
          if [ "$HTTP_SUCCESS" = false ]; then
            echo "‚ùå Apache is not responding to HTTP requests on $INSTANCE_IP"
            echo "Checking Apache status and logs..."
            ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
              echo '=== Apache Status ==='
              sudo systemctl status apache2 --no-pager || echo 'Apache status unknown'
              echo '=== Apache Error Log (last 10 lines) ==='
              sudo tail -10 /var/log/apache2/error.log 2>/dev/null || echo 'No error log found'
              echo '=== Apache Configuration Test ==='
              sudo apache2ctl configtest 2>&1 || echo 'Configuration test failed'
              echo '=== Enabled Modules ==='
              sudo apache2ctl -M 2>/dev/null || echo 'Cannot list modules'
              echo '=== Process Check ==='
              ps aux | grep apache2 | head -5
            " || echo "Could not retrieve debug information"
            continue
          fi
          
          echo "Deploying application files to $INSTANCE_IP..."
          if scp -i private_key.pem -o StrictHostKeyChecking=no -r app/* ubuntu@$INSTANCE_IP:/tmp/ 2>/dev/null; then
            echo "‚úÖ App files copied successfully"
          else
            echo "‚ùå Failed to copy app files to $INSTANCE_IP"
            continue
          fi
          
          echo "Setting up web application on $INSTANCE_IP..."
          DEPLOY_SCRIPT=$(cat << 'DEPLOY_EOF'
            set -e
            echo 'Deploying application files...'
            
            sudo cp -r /var/www/html /var/www/html.backup.$(date +%s) 2>/dev/null || echo 'No existing files to backup'
            
            echo 'Copying application files...'
            sudo cp /tmp/*.php /var/www/html/ 2>/dev/null && echo 'PHP files copied' || echo 'No PHP files found'
            sudo cp /tmp/*.css /var/www/html/ 2>/dev/null && echo 'CSS files copied' || echo 'No CSS files found'
            
            if [ -f /var/www/html/index.php ]; then
              echo 'Removing placeholder index.html to prioritize index.php'
              sudo rm -f /var/www/html/index.html
              sudo rm -f /var/www/html/loading.html
              echo '‚úÖ index.php will now be served by default'
            fi
            
            echo 'Configuring Apache DirectoryIndex...'
            sudo bash -c 'cat > /etc/apache2/conf-available/directory-index.conf << "EOF"
        DirectoryIndex index.php index.html index.htm
        EOF'
            sudo a2enconf directory-index 2>/dev/null || echo 'DirectoryIndex config already enabled'
            
            sudo chown -R www-data:www-data /var/www/html/
            sudo chmod 755 /var/www/html/
            sudo chmod 644 /var/www/html/*.php 2>/dev/null || echo 'No PHP files to set permissions'
            sudo chmod 644 /var/www/html/*.css 2>/dev/null || echo 'No CSS files to set permissions'
            
            echo 'Validating PHP syntax...'
            for phpfile in /var/www/html/*.php; do
              if [ -f "$phpfile" ]; then
                if ! php -l "$phpfile" >/dev/null 2>&1; then
                  echo "‚ùå PHP syntax error in $phpfile"
                  php -l "$phpfile" || true
                  exit 1
                fi
              fi
            done
            echo '‚úÖ All PHP files have valid syntax'
            
            echo 'Testing database configuration...'
            if [ -f /var/www/html/.db_config ]; then
              echo 'Database config file exists'
              source /var/www/html/.db_config
              
              if [ "$DB_HOST" != "localhost" ] && [ "$DB_HOST" != "placeholder" ] && [ -n "$DB_HOST" ]; then
                echo "Testing connection to database: $DB_HOST"
                
                if timeout 15 mysql -h "$DB_HOST" -u "$DB_USER" -p"$DB_PASSWORD" -e "SELECT 1;" >/dev/null 2>&1; then
                  echo '‚úÖ Database connection successful'
                  
                  if mysql -h "$DB_HOST" -u "$DB_USER" -p"$DB_PASSWORD" -e "USE $DB_NAME; SHOW TABLES LIKE 'tasks';" 2>/dev/null | grep -q 'tasks'; then
                    echo '‚úÖ Application database and tables are ready'
                  else
                    echo '‚ö†Ô∏è Creating database and tables...'
                    mysql -h "$DB_HOST" -u "$DB_USER" -p"$DB_PASSWORD" << 'MYSQL_EOF'
        CREATE DATABASE IF NOT EXISTS proxylamptodoapp;
        USE proxylamptodoapp;
        CREATE TABLE IF NOT EXISTS tasks (
            id INT AUTO_INCREMENT PRIMARY KEY,
            task VARCHAR(255) NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            status ENUM('pending','completed') DEFAULT 'pending',
            INDEX idx_created_at (created_at),
            INDEX idx_status (status)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

        INSERT INTO tasks (task) VALUES ('üéâ Welcome to your Proxy LAMP Stack Todo Application!') ON DUPLICATE KEY UPDATE task=task;
        MYSQL_EOF
                    echo '‚úÖ Database and tables created successfully'
                  fi
                else
                  echo '‚ö†Ô∏è Database connection failed - application may not work properly'
                  echo "Database host: $DB_HOST"
                  echo 'This might be due to timing - database may not be ready yet'
                fi
              else
                echo '‚ö†Ô∏è Database configuration appears to be placeholder or invalid'
                echo "DB_HOST: $DB_HOST"
              fi
            else
              echo '‚ùå Database config file not found'
              exit 1
            fi
            
            echo 'Testing Apache configuration...'
            if ! sudo apache2ctl configtest 2>/dev/null; then
              echo '‚ùå Apache configuration test failed'
              sudo apache2ctl configtest 2>&1 || true
              
              echo 'Attempting to fix Apache configuration...'
              sudo a2enmod remoteip headers rewrite ssl status 2>/dev/null || true
              
              if ! sudo apache2ctl configtest 2>/dev/null; then
                echo 'Configuration still has issues - disabling custom configs'
                sudo a2disconf load-balancer 2>/dev/null || true
              fi
            fi
            echo '‚úÖ Apache configuration is valid'
            
            echo 'Restarting Apache...'
            if sudo systemctl restart apache2; then
              echo '‚úÖ Apache restarted successfully'
            else
              echo '‚ùå Apache restart failed'
              sudo systemctl status apache2 --no-pager || true
              exit 1
            fi
            
            sleep 5
            
            echo 'Testing final connectivity...'
            SUCCESS=false
            for attempt in {1..15}; do
              RESPONSE=$(curl -s http://localhost/ | head -1)
              if echo "$RESPONSE" | grep -q "DOCTYPE html" && ! echo "$RESPONSE" | grep -q "LAMP Stack Ready"; then
                echo "‚úÖ Application is responding with proper content (attempt $attempt)"
                SUCCESS=true
                break
              elif curl -s -f http://localhost/ > /dev/null; then
                echo "‚è≥ Server responding but may be serving wrong content (attempt $attempt)"
                sleep 2
              else
                echo "‚è≥ Application test failed, attempt $attempt/15"
                sleep 2
              fi
            done
            
            if [ "$SUCCESS" = false ]; then
              echo '‚ùå Application is not responding properly after deployment'
              echo 'Final diagnostics:'
              echo '=== Web Directory Contents ==='
              ls -la /var/www/html/
              echo '=== Testing what Apache serves ==='
              curl -s http://localhost/ | head -5
              sudo systemctl status apache2 --no-pager || true
              sudo tail -5 /var/log/apache2/error.log 2>/dev/null || echo 'No error log'
              ps aux | grep apache2 | head -3
              exit 1
            fi
            
            echo 'Testing health endpoint...'
            HEALTH_SUCCESS=false
            for attempt in {1..10}; do
              HEALTH_RESPONSE=$(curl -s http://localhost/health.php 2>/dev/null || echo 'failed')
              if echo "$HEALTH_RESPONSE" | grep -q '"status"'; then
                echo '‚úÖ Health endpoint is responding with JSON'
                HEALTH_SUCCESS=true
                break
              else
                echo "‚è≥ Health endpoint test attempt $attempt/10"
                sleep 2
              fi
            done
            
            if [ "$HEALTH_SUCCESS" = false ]; then
              echo '‚ö†Ô∏è Health endpoint is not responding properly'
              echo 'Testing direct health endpoint:'
              curl -v http://localhost/health.php || echo 'Health endpoint test failed'
            fi
            
            echo 'Testing main application functionality...'
            if curl -s http://localhost/ | grep -q "Proxy LAMP Stack"; then
              echo '‚úÖ Main application page is accessible and contains expected content'
            else
              echo '‚ö†Ô∏è Main application page may not be correct'
              echo 'Response preview:'
              curl -s http://localhost/ | head -3
            fi
            
            echo '‚úÖ Application deployment successful'
        DEPLOY_EOF
          )
          
          if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "$DEPLOY_SCRIPT"; then
            echo "‚úÖ Successfully deployed to $INSTANCE_IP"
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            
            echo "=== Post-deployment Verification for $INSTANCE_IP ==="
            
            MAIN_PAGE_TEST=$(ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "curl -s http://localhost/ | head -2" 2>/dev/null || echo "test failed")
            if echo "$MAIN_PAGE_TEST" | grep -q "Proxy LAMP Stack"; then
              echo "‚úÖ Main application is being served correctly"
            else
              echo "‚ö†Ô∏è May still be serving placeholder page"
              echo "Response: $MAIN_PAGE_TEST"
            fi
            
            HEALTH_TEST=$(ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "curl -s http://localhost/health.php | head -1" 2>/dev/null || echo "health test failed")
            if echo "$HEALTH_TEST" | grep -q '"status"'; then
              echo "‚úÖ Health endpoint working"
            else
              echo "‚ö†Ô∏è Health endpoint may have issues"
              echo "Response: $HEALTH_TEST"
            fi
          else
            echo "‚ùå Deployment failed on $INSTANCE_IP"
            
            echo "=== Additional Diagnostics for $INSTANCE_IP ==="
            ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
              echo 'System load:'
              uptime
              echo 'Disk space:'
              df -h /
              echo 'Memory usage:'
              free -h
              echo 'Web directory contents:'
              ls -la /var/www/html/
              echo 'What Apache is serving:'
              curl -s http://localhost/ | head -3
              echo 'Recent system messages:'
              sudo tail -5 /var/log/syslog 2>/dev/null || echo 'No syslog available'
            " 2>/dev/null || echo "Could not retrieve additional diagnostics"
          fi
        done
        
        rm -f private_key.pem
        
        echo "===================="
        echo "DEPLOYMENT SUMMARY"
        echo "===================="
        echo "Total instances: $TOTAL_COUNT"
        echo "Successful deployments: $SUCCESS_COUNT"
        echo "Failed deployments: $((TOTAL_COUNT - SUCCESS_COUNT))"
        
        if [ $SUCCESS_COUNT -gt 0 ]; then
          echo "üéâ Application deployed successfully to $SUCCESS_COUNT instance(s)!"
          echo "üåê Access your load-balanced application at: http://$LOAD_BALANCER_DNS"
          
          echo "Updating Auto Scaling Group health check type to ELB..."
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name "${{ needs.terraform.outputs.autoscaling_group_name }}" \
            --health-check-type ELB \
            --health-check-grace-period 300 || echo "Warning: Could not update health check type"
            
          echo ""
          echo "=== USEFUL LINKS ==="
          echo "üåê Application: http://$LOAD_BALANCER_DNS"
          echo "üîç Health Check: http://$LOAD_BALANCER_DNS/health.php"
          echo "üìä AWS Console: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}"
        else
          echo "‚ùå All deployments failed!"
          exit 1
        fi

  health_check:
    name: 'Health Check and Monitoring Setup'
    runs-on: ubuntu-latest
    needs: [terraform, deploy]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Load Balancer Health Checks
      env:
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        echo "Waiting for load balancer and application to be fully ready..."
        sleep 120
        
        echo "Load balancer DNS: $LOAD_BALANCER_DNS"
        
        HEALTH_SUCCESS=false
        APP_SUCCESS=false
        
        for i in {1..30}; do
          echo "Testing load balancer... attempt $i/30"
          
          if curl -f -s -m 15 "http://$LOAD_BALANCER_DNS/health.php" > /dev/null 2>&1; then
            echo "‚úÖ Health endpoint is responding!"
            HEALTH_SUCCESS=true
          fi
          
          if curl -f -s -m 15 "http://$LOAD_BALANCER_DNS/" > /dev/null 2>&1; then
            echo "‚úÖ Main application is responding!"
            APP_SUCCESS=true
          fi
          
          if [ "$HEALTH_SUCCESS" = "true" ] && [ "$APP_SUCCESS" = "true" ]; then
            echo "‚úÖ Both health check and application are responding!"
            break
          fi
          
          if [ "$HEALTH_SUCCESS" = "true" ] || [ "$APP_SUCCESS" = "true" ]; then
            echo "‚è≥ Partial success, continuing checks..."
          else
            echo "‚è≥ No response yet, waiting..."
          fi
          
          if [ $i -eq 30 ]; then
            echo "‚ùå Health checks did not pass after 30 attempts"
            
            echo "üîç Debugging information:"
            echo "Load balancer DNS: $LOAD_BALANCER_DNS"
            
            if nslookup "$LOAD_BALANCER_DNS" > /dev/null 2>&1; then
              echo "‚úÖ DNS resolution works"
            else
              echo "‚ùå DNS resolution failed"
            fi
            
            if ping -c 3 "$LOAD_BALANCER_DNS" > /dev/null 2>&1; then
              echo "‚úÖ Load balancer is reachable via ping"
            else
              echo "‚ùå Load balancer is not reachable via ping"
            fi
            
            echo "Detailed health endpoint test:"
            curl -v -m 15 "http://$LOAD_BALANCER_DNS/health.php" 2>&1 || echo "Health endpoint test failed"
            
            echo "Detailed main application test:"
            curl -v -m 15 "http://$LOAD_BALANCER_DNS/" 2>&1 || echo "Main application test failed"
            
            echo "Checking load balancer target health..."
            LB_ARN=$(aws elbv2 describe-load-balancers --names "*proxy-lamp*" --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "unknown")
            if [ "$LB_ARN" != "unknown" ] && [ "$LB_ARN" != "None" ]; then
              TG_ARN=$(aws elbv2 describe-target-groups --load-balancer-arn "$LB_ARN" --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "unknown")
              if [ "$TG_ARN" != "unknown" ] && [ "$TG_ARN" != "None" ]; then
                echo "Target group health:"
                aws elbv2 describe-target-health --target-group-arn "$TG_ARN" --output table 2>/dev/null || echo "Could not get target health"
              fi
            fi
            
            if [ "$HEALTH_SUCCESS" = "true" ] || [ "$APP_SUCCESS" = "true" ]; then
              echo "‚ö†Ô∏è Partial health check success - deployment considered successful"
              echo "üåê Try accessing: http://$LOAD_BALANCER_DNS"
              break
            else
              echo "‚ùå Complete health check failure"
              exit 1
            fi
          else
            sleep 60
          fi
        done
        
        echo ""
        echo "=== FINAL DEPLOYMENT STATUS ==="
        echo "üåê Application URL: http://$LOAD_BALANCER_DNS"
        echo "üîç Health Check: http://$LOAD_BALANCER_DNS/health.php"
        echo "üìä AWS Console: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}"
        echo ""
        
        echo "=== FINAL VERIFICATION ==="
        
        if curl -f -s -m 10 "http://$LOAD_BALANCER_DNS/health.php" > /tmp/final_health.json 2>/dev/null; then
          echo "‚úÖ Health endpoint final test: PASSED"
          if command -v jq >/dev/null 2>&1 && [ -f /tmp/final_health.json ]; then
            HEALTH_STATUS=$(jq -r '.status // "unknown"' /tmp/final_health.json 2>/dev/null || echo "unknown")
            SERVER_NAME=$(jq -r '.server // "unknown"' /tmp/final_health.json 2>/dev/null || echo "unknown")
            echo "   Status: $HEALTH_STATUS"
            echo "   Server: $SERVER_NAME"
            
            DB_STATUS=$(jq -r '.checks.database.status // "unknown"' /tmp/final_health.json 2>/dev/null || echo "unknown")
            echo "   Database: $DB_STATUS"
          fi
        else
          echo "‚ö†Ô∏è Health endpoint final test: FAILED"
        fi
        
        if curl -f -s -m 10 "http://$LOAD_BALANCER_DNS/" > /dev/null 2>/dev/null; then
          echo "‚úÖ Main application final test: PASSED"
        else
          echo "‚ö†Ô∏è Main application final test: FAILED"
        fi
        
        echo ""
        echo "üöÄ Deployment completed!"
        echo "üìù Note: It may take a few more minutes for all health checks to stabilize"
        echo "üí° If you encounter issues, check the target group health in the AWS console"