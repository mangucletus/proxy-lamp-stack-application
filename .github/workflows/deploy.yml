# GitHub Actions workflow to deploy a Proxy LAMP Stack application on AWS EC2 with Load Balancer

name: Deploy Proxy LAMP Stack with Load Balancer

# Triggers the workflow when code is pushed or a pull request is opened on the 'main' branch
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Environment variables shared across all jobs
env:
  AWS_REGION: eu-central-1                         # AWS region to deploy the infrastructure (UPDATED)
  TF_VERSION: 1.5.0                             # Terraform version to use
  DEPLOYMENT_BUCKET: proxy-lamp-deployment-cletusmangu-1749764715 # S3 bucket for deployment artifacts

jobs:
  terraform:
    name: 'Terraform Infrastructure'
    runs-on: ubuntu-latest                     # Run this job on the latest Ubuntu GitHub-hosted runner
    outputs:
      load_balancer_dns: ${{ steps.terraform-output.outputs.load_balancer_dns }}  # Pass ALB DNS to the next job
      instance_ips: ${{ steps.terraform-output.outputs.instance_ips }}  # Pass EC2 instance IPs
    
    defaults:
      run:
        shell: bash
        working-directory: ./terraform         # All shell commands will run inside the ./terraform directory

    steps:
    - name: Checkout
      uses: actions/checkout@v4                # Checks out your repo so the workflow can access the code

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3       # Official action to set up Terraform in the runner
      with:
        terraform_version: ${{ env.TF_VERSION }} # Use the version defined in the environment variable

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}             # Retrieved from GitHub Secrets
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      run: terraform init                      # Initializes the Terraform configuration directory

    - name: Terraform Validate
      run: terraform validate                  # Validates the Terraform syntax and configuration

    - name: Terraform Plan
      if: github.event_name == 'pull_request'  # Only runs on PRs to show the proposed changes
      run: |
        terraform plan \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -no-color
      continue-on-error: true                  # Prevents PRs from failing due to plan issues

    - name: Terraform Apply
      if: github.ref == 'refs/heads/main' && github.event_name == 'push' # Only apply on main branch push
      run: |
        terraform apply \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -auto-approve

    - name: Get Terraform Outputs
      if: github.ref == 'refs/heads/main'
      id: terraform-output
      run: |
        echo "load_balancer_dns=$(terraform output -raw load_balancer_dns)" >> $GITHUB_OUTPUT
        echo "instance_ips=$(terraform output -json instance_ips)" >> $GITHUB_OUTPUT
        # Extracts Load Balancer DNS and EC2 instance IPs for the next job
  
  deploy:
    name: 'Deploy Application to Load Balanced Infrastructure'
    runs-on: ubuntu-latest                     # Another job on Ubuntu runner
    needs: terraform                           # Depends on the 'terraform' job to complete successfully
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout
      uses: actions/checkout@v4                # Pulls down the latest repo contents

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Infrastructure to be Ready
      run: |
        echo "Waiting for Auto Scaling Group instances to be fully initialized..."
        sleep 300  # Allows time for all EC2 instances in ASG to run user_data.sh and fully configure

    - name: Deploy Application to All Instances
      env:
        PRIVATE_KEY: ${{ secrets.EC2_PRIVATE_KEY }}              # Private key to SSH into EC2
        INSTANCE_IPS: ${{ needs.terraform.outputs.instance_ips }}  # IPs from previous job output
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        # Save the private key to a PEM file
        echo "$PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem  # Restrict permissions so SSH doesn't complain
        
        # Parse instance IPs from JSON array
        INSTANCE_LIST=$(echo '${{ needs.terraform.outputs.instance_ips }}' | jq -r '.[]')
        
        # Deploy to each instance in the Auto Scaling Group
        for INSTANCE_IP in $INSTANCE_LIST; do
          echo "Deploying to instance: $INSTANCE_IP"
          
          # Retry logic for establishing SSH connection (up to 20 tries)
          echo "Waiting for SSH connection to $INSTANCE_IP..."
          for i in {1..20}; do
            if ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@$INSTANCE_IP "echo 'SSH connection successful'"; then
              echo "SSH connection established to $INSTANCE_IP!"
              break
            fi
            echo "Waiting for SSH... attempt $i/20"
            sleep 15
          done
          
          # Copy application files from the local repo to the EC2 instance
          echo "Deploying application files to $INSTANCE_IP..."
          scp -i private_key.pem -o StrictHostKeyChecking=no -r app/* ubuntu@$INSTANCE_IP:/tmp/
          scp -i private_key.pem -o StrictHostKeyChecking=no -r monitoring/* ubuntu@$INSTANCE_IP:/tmp/
          
          # Connect to EC2 and finalize deployment
          echo "Setting up web application on $INSTANCE_IP..."
          ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
            # Wait for LAMP stack setup to complete
            while [ ! -f /var/log/cloud-init-output.log ] || ! grep -q 'LAMP Stack installation completed' /var/log/cloud-init-output.log; do
              echo 'Waiting for LAMP stack installation to complete...'
              sleep 30
            done
            
            # Move the PHP/CSS files to Apache's document root
            sudo cp /tmp/*.php /tmp/*.css /var/www/html/ 2>/dev/null || echo 'Some files may not exist, continuing...'
            
            # Set up monitoring
            sudo cp /tmp/cloudwatch-agent.json /opt/aws/amazon-cloudwatch-agent/etc/
            sudo cp /tmp/custom-metrics.sh /usr/local/bin/
            sudo chmod +x /usr/local/bin/custom-metrics.sh
            
            # Set correct permissions
            sudo chown -R www-data:www-data /var/www/html/
            sudo chmod -R 755 /var/www/html/
            
            # Start CloudWatch agent
            sudo /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
              -a fetch-config -m ec2 -s -c file:/opt/aws/amazon-cloudwatch-agent/etc/cloudwatch-agent.json
            
            # Restart Apache and enable monitoring
            sudo systemctl restart apache2
            sudo systemctl enable amazon-cloudwatch-agent
            
            # Set up custom metrics cron job
            (crontab -l 2>/dev/null; echo '*/5 * * * * /usr/local/bin/custom-metrics.sh') | crontab -
            
            # Confirm files are in place
            echo 'Application deployment completed on $INSTANCE_IP!'
            ls -la /var/www/html/
          "
        done
        
        # Clean up local PEM file
        rm -f private_key.pem
        
        # Final deployment success message
        echo "ğŸ‰ Application deployed successfully to all instances!"
        echo "ğŸŒ Access your load-balanced application at: http://$LOAD_BALANCER_DNS"

  health_check:
    name: 'Health Check and Monitoring Setup'
    runs-on: ubuntu-latest
    needs: [terraform, deploy]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Load Balancer Health Checks
      env:
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        echo "Waiting for load balancer health checks to pass..."
        sleep 180  # Allow time for health checks to stabilize
        
        # Test load balancer endpoint
        for i in {1..10}; do
          if curl -f -s "http://$LOAD_BALANCER_DNS/health.php" > /dev/null; then
            echo "âœ… Load balancer health check passed!"
            echo "ğŸŒ Application is healthy at: http://$LOAD_BALANCER_DNS"
            break
          else
            echo "â³ Waiting for health check... attempt $i/10"
            sleep 30
          fi
        done
        
        # Final verification
        echo "Final application test:"
        curl -s "http://$LOAD_BALANCER_DNS/health.php" || echo "Health check endpoint not responding"
        echo "Deployment completed successfully! ğŸš€"