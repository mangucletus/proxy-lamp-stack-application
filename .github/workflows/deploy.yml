# GitHub Actions workflow to deploy a Proxy LAMP Stack application on AWS EC2 with Load Balancer

name: Deploy Proxy LAMP Stack with Load Balancer

# THIS WAS MISSING - Event triggers
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Environment variables shared across all jobs
env:
  AWS_REGION: eu-central-1
  TF_VERSION: 1.5.0
  DEPLOYMENT_BUCKET: proxy-lamp-deployment-cletusmangu-1749764715

jobs:
  terraform:
    name: 'Terraform Infrastructure'
    runs-on: ubuntu-latest
    outputs:
      load_balancer_dns: ${{ steps.terraform-output.outputs.load_balancer_dns }}
      autoscaling_group_name: ${{ steps.terraform-output.outputs.autoscaling_group_name }}
    
    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      run: terraform init

    - name: Terraform Validate
      run: terraform validate

    - name: Terraform Plan
      if: github.event_name == 'pull_request'
      run: |
        terraform plan \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -no-color
      continue-on-error: true

    - name: Terraform Apply
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        terraform apply \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -auto-approve

    - name: Get Terraform Outputs
      if: github.ref == 'refs/heads/main'
      id: terraform-output
      run: |
        echo "load_balancer_dns=$(terraform output -raw load_balancer_dns)" >> $GITHUB_OUTPUT
        echo "autoscaling_group_name=$(terraform output -raw autoscaling_group_name)" >> $GITHUB_OUTPUT

  deploy:
    name: 'Deploy Application to Load Balanced Infrastructure'
    runs-on: ubuntu-latest
    needs: terraform
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Infrastructure to be Ready
      run: |
        echo "Waiting for Auto Scaling Group instances to be fully initialized..."
        sleep 120

    - name: Get Instance IPs from Auto Scaling Group
      id: get-instances
      env:
        ASG_NAME: ${{ needs.terraform.outputs.autoscaling_group_name }}
      run: |
        echo "Getting instance IPs from Auto Scaling Group: $ASG_NAME"
        
        # FIXED: Get ALL instances, not just InService ones
        echo "=== All instances in ASG ==="
        aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names "$ASG_NAME" \
          --query 'AutoScalingGroups[0].Instances[*].{InstanceId:InstanceId,State:LifecycleState,Health:HealthStatus}' \
          --output table
        
        # Get instance IDs from ASG (any state - running instances)
        ALL_INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names "$ASG_NAME" \
          --query 'AutoScalingGroups[0].Instances[*].InstanceId' \
          --output text)
        
        echo "All Instance IDs: $ALL_INSTANCE_IDS"
        
        if [ -z "$ALL_INSTANCE_IDS" ]; then
          echo "âŒ No instances found in Auto Scaling Group at all!"
          exit 1
        fi
        
        # Filter for running instances only (regardless of ASG lifecycle state)
        echo "=== Checking which instances are actually running ==="
        RUNNING_INSTANCES=""
        for INSTANCE_ID in $ALL_INSTANCE_IDS; do
          INSTANCE_STATE=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].State.Name' \
            --output text 2>/dev/null || echo "unknown")
          
          echo "Instance $INSTANCE_ID state: $INSTANCE_STATE"
          
          if [ "$INSTANCE_STATE" = "running" ]; then
            RUNNING_INSTANCES="$RUNNING_INSTANCES $INSTANCE_ID"
          fi
        done
        
        RUNNING_INSTANCES=$(echo "$RUNNING_INSTANCES" | xargs)  # Trim whitespace
        echo "Running instances: $RUNNING_INSTANCES"
        
        if [ -z "$RUNNING_INSTANCES" ]; then
          echo "âŒ No running instances found!"
          exit 1
        fi
        
        # Get public IP addresses for running instances
        echo "=== Getting IP addresses for running instances ==="
        INSTANCE_IPS=$(aws ec2 describe-instances \
          --instance-ids $RUNNING_INSTANCES \
          --query 'Reservations[].Instances[?State.Name==`running`].PublicIpAddress' \
          --output text | tr '\t' ' ')
        
        echo "Public IPs: $INSTANCE_IPS"
        
        # If no public IPs, try private IPs
        if [ -z "$INSTANCE_IPS" ] || [ "$INSTANCE_IPS" = "None" ]; then
          echo "No public IPs found, trying private IPs..."
          INSTANCE_IPS=$(aws ec2 describe-instances \
            --instance-ids $RUNNING_INSTANCES \
            --query 'Reservations[].Instances[?State.Name==`running`].PrivateIpAddress' \
            --output text | tr '\t' ' ')
          echo "Private IPs: $INSTANCE_IPS"
        fi
        
        if [ -z "$INSTANCE_IPS" ]; then
          echo "âŒ No IP addresses found for running instances!"
          exit 1
        fi
        
        # Store IPs in environment for next step
        echo "INSTANCE_IPS=$INSTANCE_IPS" >> $GITHUB_ENV
        echo "âœ… Found instances with IPs: $INSTANCE_IPS"

    - name: Deploy Application to All Instances
      env:
        PRIVATE_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        # Save the private key to a PEM file
        echo "$PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem
        
        echo "Instance IPs to deploy to: $INSTANCE_IPS"
        
        SUCCESS_COUNT=0
        TOTAL_COUNT=0
        
        # Deploy to each instance
        for INSTANCE_IP in $INSTANCE_IPS; do
          echo "===================="
          echo "Deploying to instance: $INSTANCE_IP"
          echo "===================="
          
          TOTAL_COUNT=$((TOTAL_COUNT + 1))
          
          # Skip if IP is empty or "None"
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
            echo "Skipping empty or invalid IP: $INSTANCE_IP"
            continue
          fi
          
          # Retry logic for establishing SSH connection
          echo "Waiting for SSH connection to $INSTANCE_IP..."
          SSH_SUCCESS=false
          
          for i in {1..15}; do
            if ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ubuntu@$INSTANCE_IP "echo 'SSH connection successful'" 2>/dev/null; then
              echo "âœ… SSH connection established to $INSTANCE_IP!"
              SSH_SUCCESS=true
              break
            fi
            echo "Waiting for SSH... attempt $i/15"
            sleep 10
          done
          
          if [ "$SSH_SUCCESS" = false ]; then
            echo "âŒ Failed to establish SSH connection to $INSTANCE_IP after 15 attempts"
            echo "Skipping this instance and continuing with others..."
            continue
          fi
          
          # Copy application files
          echo "Deploying application files to $INSTANCE_IP..."
          if ! scp -i private_key.pem -o StrictHostKeyChecking=no -r app/* ubuntu@$INSTANCE_IP:/tmp/ 2>/dev/null; then
            echo "âŒ Failed to copy app files to $INSTANCE_IP"
            continue
          fi
          
          if ! scp -i private_key.pem -o StrictHostKeyChecking=no -r monitoring/* ubuntu@$INSTANCE_IP:/tmp/ 2>/dev/null; then
            echo "âŒ Failed to copy monitoring files to $INSTANCE_IP"
            continue
          fi
          
          # Deploy and configure application
          echo "Setting up web application on $INSTANCE_IP..."
          if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
            # Wait for LAMP stack setup to complete
            echo 'Waiting for LAMP stack installation to complete...'
            timeout 300 bash -c 'while [ ! -f /var/log/cloud-init-output.log ] || ! grep -q \"LAMP Stack installation completed\" /var/log/cloud-init-output.log; do
              echo \"Still waiting for LAMP stack...\"
              sleep 15
            done'
            
            # Move the PHP/CSS files to Apache's document root
            echo 'Moving application files...'
            sudo cp /tmp/*.php /var/www/html/ 2>/dev/null || echo 'Some PHP files may not exist, continuing...'
            sudo cp /tmp/*.css /var/www/html/ 2>/dev/null || echo 'Some CSS files may not exist, continuing...'
            
            # Set up monitoring
            echo 'Setting up monitoring...'
            sudo cp /tmp/cloudwatch-agent.json /opt/aws/amazon-cloudwatch-agent/etc/ 2>/dev/null || echo 'CloudWatch agent config copy failed'
            sudo cp /tmp/custom-metrics.sh /usr/local/bin/ 2>/dev/null || echo 'Custom metrics script copy failed'
            sudo chmod +x /usr/local/bin/custom-metrics.sh 2>/dev/null || echo 'Failed to make custom-metrics.sh executable'
            
            # Set correct permissions
            echo 'Setting file permissions...'
            sudo chown -R www-data:www-data /var/www/html/
            sudo chmod -R 755 /var/www/html/
            
            # Restart Apache
            echo 'Restarting services...'
            sudo systemctl restart apache2
            
            # Test web server
            echo 'Testing web server...'
            curl -s http://localhost/health.php > /dev/null && echo 'Web server is responding' || echo 'Web server test failed'
            
            # Confirm files are in place
            echo \"Application deployment completed on $INSTANCE_IP!\"
            ls -la /var/www/html/
          "; then
            echo "âœ… Successfully deployed to $INSTANCE_IP"
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          else
            echo "âŒ Deployment failed on $INSTANCE_IP"
          fi
          
          echo "Finished deployment attempt to $INSTANCE_IP"
        done
        
        # Clean up local PEM file
        rm -f private_key.pem
        
        # Final deployment summary
        echo "===================="
        echo "DEPLOYMENT SUMMARY"
        echo "===================="
        echo "Total instances: $TOTAL_COUNT"
        echo "Successful deployments: $SUCCESS_COUNT"
        echo "Failed deployments: $((TOTAL_COUNT - SUCCESS_COUNT))"
        
        if [ $SUCCESS_COUNT -gt 0 ]; then
          echo "ğŸ‰ Application deployed successfully to $SUCCESS_COUNT instance(s)!"
          echo "ğŸŒ Access your load-balanced application at: http://$LOAD_BALANCER_DNS"
        else
          echo "âŒ All deployments failed!"
          exit 1
        fi

  health_check:
    name: 'Health Check and Monitoring Setup'
    runs-on: ubuntu-latest
    needs: [terraform, deploy]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Load Balancer Health Checks
      env:
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        echo "Waiting for load balancer health checks to pass..."
        sleep 180
        
        # Test load balancer endpoint
        for i in {1..10}; do
          echo "Testing load balancer... attempt $i/10"
          if curl -f -s "http://$LOAD_BALANCER_DNS/health.php" > /dev/null; then
            echo "âœ… Load balancer health check passed!"
            echo "ğŸŒ Application is healthy at: http://$LOAD_BALANCER_DNS"
            break
          else
            echo "â³ Waiting for health check... attempt $i/10"
            if [ $i -eq 10 ]; then
              echo "âŒ Health check failed after 10 attempts"
              echo "ğŸ” Trying main page instead..."
              if curl -f -s "http://$LOAD_BALANCER_DNS/" > /dev/null; then
                echo "âœ… Main application page is accessible"
              else
                echo "âŒ Main application page is also not accessible"
              fi
            else
              sleep 30
            fi
          fi
        done
        
        echo "Deployment completed! ğŸš€"