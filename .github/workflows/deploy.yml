deploy:
    name: 'Deploy Application to Load Balanced Infrastructure'
    runs-on: ubuntu-latest                     # Another job on Ubuntu runner
    needs: terraform                           # Depends on the 'terraform' job to complete successfully
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout
      uses: actions/checkout@v4                # Pulls down the latest repo contents

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Infrastructure to be Ready
      run: |
        echo "Waiting for Auto Scaling Group instances to be fully initialized..."
        sleep 120  # Reduced initial wait time

    - name: Debug Auto Scaling Group Status
      env:
        ASG_NAME: ${{ needs.terraform.outputs.autoscaling_group_name }}
      run: |
        echo "=== Auto Scaling Group Debug Information ==="
        echo "ASG Name: $ASG_NAME"
        
        # Check if ASG exists
        if ! aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" --query 'AutoScalingGroups[0]' > /dev/null 2>&1; then
          echo "ERROR: Auto Scaling Group '$ASG_NAME' not found!"
          exit 1
        fi
        
        # Get ASG details
        echo "=== ASG Configuration ==="
        aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names "$ASG_NAME" \
          --query 'AutoScalingGroups[0].{MinSize:MinSize,MaxSize:MaxSize,DesiredCapacity:DesiredCapacity,Instances:length(Instances)}' \
          --output table
        
        # Get all instances (regardless of state)
        echo "=== All Instances in ASG ==="
        aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names "$ASG_NAME" \
          --query 'AutoScalingGroups[0].Instances[*].{InstanceId:InstanceId,LifecycleState:LifecycleState,HealthStatus:HealthStatus,AvailabilityZone:AvailabilityZone}' \
          --output table

    - name: Wait for Instances to be InService
      env:
        ASG_NAME: ${{ needs.terraform.outputs.autoscaling_group_name }}
      run: |
        echo "Waiting for instances to reach InService state..."
        
        MAX_WAIT_MINUTES=20
        WAIT_INTERVAL=30
        ATTEMPTS=$((MAX_WAIT_MINUTES * 60 / WAIT_INTERVAL))
        
        for i in $(seq 1 $ATTEMPTS); do
          echo "=== Attempt $i/$ATTEMPTS ==="
          
          # Get InService instances
          INSERVICE_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
            --output text)
          
          # Get desired capacity
          DESIRED_CAPACITY=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --query 'AutoScalingGroups[0].DesiredCapacity' \
            --output text)
          
          # Count InService instances
          if [ -n "$INSERVICE_INSTANCES" ]; then
            INSERVICE_COUNT=$(echo "$INSERVICE_INSTANCES" | wc -w)
          else
            INSERVICE_COUNT=0
          fi
          
          echo "InService instances: $INSERVICE_COUNT/$DESIRED_CAPACITY"
          
          if [ "$INSERVICE_COUNT" -ge 1 ]; then
            echo "‚úÖ At least one instance is InService!"
            echo "INSERVICE_INSTANCES=$INSERVICE_INSTANCES" >> $GITHUB_ENV
            break
          fi
          
          # Show current instance states
          echo "Current instance states:"
          aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --query 'AutoScalingGroups[0].Instances[*].{InstanceId:InstanceId,State:LifecycleState,Health:HealthStatus}' \
            --output table
          
          if [ $i -eq $ATTEMPTS ]; then
            echo "‚ùå Timeout waiting for instances to be InService"
            echo "This might indicate:"
            echo "1. User data script is failing"
            echo "2. Health checks are failing"
            echo "3. Instance launch issues"
            
            # Try to get some instances anyway for debugging
            ALL_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "$ASG_NAME" \
              --query 'AutoScalingGroups[0].Instances[*].InstanceId' \
              --output text)
            
            if [ -n "$ALL_INSTANCES" ]; then
              echo "Found instances in other states, will try to deploy anyway: $ALL_INSTANCES"
              echo "INSERVICE_INSTANCES=$ALL_INSTANCES" >> $GITHUB_ENV
            else
              echo "No instances found at all!"
              exit 1
            fi
            break
          fi
          
          echo "Waiting $WAIT_INTERVAL seconds before next check..."
          sleep $WAIT_INTERVAL
        done

    - name: Get Instance IPs
      id: get-instances
      run: |
        if [ -z "$INSERVICE_INSTANCES" ]; then
          echo "No instances available for deployment"
          exit 1
        fi
        
        echo "Getting IP addresses for instances: $INSERVICE_INSTANCES"
        
        # Get public IP addresses for the instances
        INSTANCE_IPS=$(aws ec2 describe-instances \
          --instance-ids $INSERVICE_INSTANCES \
          --query 'Reservations[].Instances[?State.Name==`running`].PublicIpAddress' \
          --output text | tr '\t' ' ')
        
        echo "Instance IPs: $INSTANCE_IPS"
        
        if [ -z "$INSTANCE_IPS" ] || [ "$INSTANCE_IPS" = "None" ]; then
          echo "No public IP addresses found for instances"
          echo "Checking private IPs as fallback..."
          
          INSTANCE_IPS=$(aws ec2 describe-instances \
            --instance-ids $INSERVICE_INSTANCES \
            --query 'Reservations[].Instances[?State.Name==`running`].PrivateIpAddress' \
            --output text | tr '\t' ' ')
          
          if [ -z "$INSTANCE_IPS" ]; then
            echo "No IP addresses found!"
            exit 1
          else
            echo "Using private IPs: $INSTANCE_IPS"
          fi
        fi
        
        # Store IPs in environment for next step
        echo "INSTANCE_IPS=$INSTANCE_IPS" >> $GITHUB_ENV
        echo "Found instances with IPs: $INSTANCE_IPS"

    - name: Check Instance Health Before Deployment
      run: |
        echo "Checking instance health before deployment..."
        
        for INSTANCE_IP in $INSTANCE_IPS; do
          echo "Checking instance $INSTANCE_IP..."
          
          # Check if instance is reachable
          if ping -c 1 -W 5 "$INSTANCE_IP" > /dev/null 2>&1; then
            echo "‚úÖ Instance $INSTANCE_IP is reachable"
          else
            echo "‚ùå Instance $INSTANCE_IP is not reachable via ping"
          fi
          
          # Check if SSH port is open
          if timeout 10 bash -c "echo >/dev/tcp/$INSTANCE_IP/22" 2>/dev/null; then
            echo "‚úÖ SSH port is open on $INSTANCE_IP"
          else
            echo "‚ùå SSH port is not open on $INSTANCE_IP"
          fi
        done

    - name: Deploy Application to All Instances
      env:
        PRIVATE_KEY: ${{ secrets.EC2_PRIVATE_KEY }}              # Private key to SSH into EC2
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        # Save the private key to a PEM file
        echo "$PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem  # Restrict permissions so SSH doesn't complain
        
        echo "Instance IPs to deploy to: $INSTANCE_IPS"
        
        SUCCESS_COUNT=0
        TOTAL_COUNT=0
        
        # Deploy to each instance
        for INSTANCE_IP in $INSTANCE_IPS; do
          echo "===================="
          echo "Deploying to instance: $INSTANCE_IP"
          echo "===================="
          
          TOTAL_COUNT=$((TOTAL_COUNT + 1))
          
          # Skip if IP is empty or "None"
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
            echo "Skipping empty or invalid IP: $INSTANCE_IP"
            continue
          fi
          
          # Retry logic for establishing SSH connection (up to 10 tries for faster feedback)
          echo "Waiting for SSH connection to $INSTANCE_IP..."
          SSH_SUCCESS=false
          
          for i in {1..10}; do
            if ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ubuntu@$INSTANCE_IP "echo 'SSH connection successful'" 2>/dev/null; then
              echo "‚úÖ SSH connection established to $INSTANCE_IP!"
              SSH_SUCCESS=true
              break
            fi
            echo "Waiting for SSH... attempt $i/10"
            sleep 10
          done
          
          if [ "$SSH_SUCCESS" = false ]; then
            echo "‚ùå Failed to establish SSH connection to $INSTANCE_IP after 10 attempts"
            echo "Checking what's wrong..."
            
            # Get instance details for debugging
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=private-ip-address,Values=$INSTANCE_IP" "Name=state-name,Values=running" \
              --query 'Reservations[0].Instances[0].InstanceId' \
              --output text 2>/dev/null || echo "unknown")
            
            if [ "$INSTANCE_ID" != "unknown" ] && [ "$INSTANCE_ID" != "None" ]; then
              echo "Instance ID: $INSTANCE_ID"
              echo "Checking system log..."
              aws logs get-log-events \
                --log-group-name "/aws/ec2/proxy-lamp/cloud-init" \
                --log-stream-name "$INSTANCE_ID/cloud-init.log" \
                --limit 10 \
                --output text 2>/dev/null || echo "Could not retrieve cloud-init logs"
            fi
            
            echo "Skipping this instance and continuing with others..."
            continue
          fi
          
          # Copy application files from the local repo to the EC2 instance
          echo "Deploying application files to $INSTANCE_IP..."
          if ! scp -i private_key.pem -o StrictHostKeyChecking=no -r app/* ubuntu@$INSTANCE_IP:/tmp/ 2>/dev/null; then
            echo "‚ùå Failed to copy app files to $INSTANCE_IP"
            continue
          fi
          
          if ! scp -i private_key.pem -o StrictHostKeyChecking=no -r monitoring/* ubuntu@$INSTANCE_IP:/tmp/ 2>/dev/null; then
            echo "‚ùå Failed to copy monitoring files to $INSTANCE_IP"
            continue
          fi
          
          # Connect to EC2 and finalize deployment
          echo "Setting up web application on $INSTANCE_IP..."
          if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
            # Wait for LAMP stack setup to complete
            echo 'Waiting for LAMP stack installation to complete...'
            timeout 300 bash -c 'while [ ! -f /var/log/cloud-init-output.log ] || ! grep -q \"LAMP Stack installation completed\" /var/log/cloud-init-output.log; do
              echo \"Still waiting for LAMP stack...\"
              sleep 15
            done'
            
            if ! grep -q 'LAMP Stack installation completed' /var/log/cloud-init-output.log; then
              echo 'LAMP stack installation may not have completed properly'
              echo 'Checking cloud-init status...'
              cloud-init status || echo 'cloud-init status command failed'
              echo 'Continuing with deployment...'
            fi
            
            # Move the PHP/CSS files to Apache's document root
            echo 'Moving application files...'
            sudo cp /tmp/*.php /var/www/html/ 2>/dev/null || echo 'Some PHP files may not exist, continuing...'
            sudo cp /tmp/*.css /var/www/html/ 2>/dev/null || echo 'Some CSS files may not exist, continuing...'
            
            # Set up monitoring
            echo 'Setting up monitoring...'
            sudo cp /tmp/cloudwatch-agent.json /opt/aws/amazon-cloudwatch-agent/etc/ 2>/dev/null || echo 'CloudWatch agent config copy failed'
            sudo cp /tmp/custom-metrics.sh /usr/local/bin/ 2>/dev/null || echo 'Custom metrics script copy failed'
            sudo chmod +x /usr/local/bin/custom-metrics.sh 2>/dev/null || echo 'Failed to make custom-metrics.sh executable'
            
            # Set correct permissions
            echo 'Setting file permissions...'
            sudo chown -R www-data:www-data /var/www/html/
            sudo chmod -R 755 /var/www/html/
            
            # Start CloudWatch agent
            echo 'Starting CloudWatch agent...'
            sudo /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
              -a fetch-config -m ec2 -s -c file:/opt/aws/amazon-cloudwatch-agent/etc/cloudwatch-agent.json 2>/dev/null || echo 'CloudWatch agent start failed'
            
            # Restart Apache and enable monitoring
            echo 'Restarting services...'
            sudo systemctl restart apache2
            sudo systemctl enable amazon-cloudwatch-agent 2>/dev/null || echo 'Failed to enable CloudWatch agent'
            
            # Set up custom metrics cron job
            echo 'Setting up cron job...'
            (crontab -l 2>/dev/null; echo '*/5 * * * * /usr/local/bin/custom-metrics.sh') | crontab - 2>/dev/null || echo 'Cron setup failed'
            
            # Test web server
            echo 'Testing web server...'
            curl -s http://localhost/health.php > /dev/null && echo 'Web server is responding' || echo 'Web server test failed'
            
            # Confirm files are in place
            echo \"Application deployment completed on $INSTANCE_IP!\"
            ls -la /var/www/html/
          "; then
            echo "‚úÖ Successfully deployed to $INSTANCE_IP"
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          else
            echo "‚ùå Deployment failed on $INSTANCE_IP"
          fi
          
          echo "Finished deployment attempt to $INSTANCE_IP"
        done
        
        # Clean up local PEM file
        rm -f private_key.pem
        
        # Final deployment summary
        echo "===================="
        echo "DEPLOYMENT SUMMARY"
        echo "===================="
        echo "Total instances: $TOTAL_COUNT"
        echo "Successful deployments: $SUCCESS_COUNT"
        echo "Failed deployments: $((TOTAL_COUNT - SUCCESS_COUNT))"
        
        if [ $SUCCESS_COUNT -gt 0 ]; then
          echo "üéâ Application deployed successfully to $SUCCESS_COUNT instance(s)!"
          echo "üåê Access your load-balanced application at: http://$LOAD_BALANCER_DNS"
        else
          echo "‚ùå All deployments failed!"
          exit 1
        fi