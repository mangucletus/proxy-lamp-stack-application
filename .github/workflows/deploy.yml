# GitHub Actions workflow to deploy a Proxy LAMP Stack application on AWS EC2 with Load Balancer

name: Deploy Proxy LAMP Stack with Load Balancer

# Event triggers
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Environment variables shared across all jobs
env:
  AWS_REGION: eu-central-1
  TF_VERSION: 1.5.0
  DEPLOYMENT_BUCKET: proxy-lamp-deployment-cletusmangu-1749764715

jobs:
  terraform:
    name: 'Terraform Infrastructure'
    runs-on: ubuntu-latest
    outputs:
      load_balancer_dns: ${{ steps.terraform-output.outputs.load_balancer_dns }}
      autoscaling_group_name: ${{ steps.terraform-output.outputs.autoscaling_group_name }}
    
    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      run: terraform init

    - name: Terraform Validate
      run: terraform validate

    - name: Terraform Plan
      if: github.event_name == 'pull_request'
      run: |
        terraform plan \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -no-color
      continue-on-error: true

    - name: Terraform Apply
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        terraform apply \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -auto-approve

    - name: Get Terraform Outputs
      if: github.ref == 'refs/heads/main'
      id: terraform-output
      run: |
        echo "load_balancer_dns=$(terraform output -raw load_balancer_dns)" >> $GITHUB_OUTPUT
        echo "autoscaling_group_name=$(terraform output -raw autoscaling_group_name)" >> $GITHUB_OUTPUT

  deploy:
    name: 'Deploy Application to Load Balanced Infrastructure'
    runs-on: ubuntu-latest
    needs: terraform
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Infrastructure to be Ready
      run: |
        echo "Waiting for Auto Scaling Group instances to be fully initialized..."
        sleep 120

    - name: Get Instance IPs from Auto Scaling Group
      id: get-instances
      env:
        ASG_NAME: ${{ needs.terraform.outputs.autoscaling_group_name }}
      run: |
        echo "Getting instance IPs from Auto Scaling Group: $ASG_NAME"
        
        # Get ALL instances, not just InService ones
        echo "=== All instances in ASG ==="
        aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names "$ASG_NAME" \
          --query 'AutoScalingGroups[0].Instances[*].{InstanceId:InstanceId,State:LifecycleState,Health:HealthStatus}' \
          --output table
        
        # Get instance IDs from ASG (any state - running instances)
        ALL_INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names "$ASG_NAME" \
          --query 'AutoScalingGroups[0].Instances[*].InstanceId' \
          --output text)
        
        echo "All Instance IDs: $ALL_INSTANCE_IDS"
        
        if [ -z "$ALL_INSTANCE_IDS" ]; then
          echo "‚ùå No instances found in Auto Scaling Group at all!"
          exit 1
        fi
        
        # Filter for running instances only (regardless of ASG lifecycle state)
        echo "=== Checking which instances are actually running ==="
        RUNNING_INSTANCES=""
        for INSTANCE_ID in $ALL_INSTANCE_IDS; do
          INSTANCE_STATE=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].State.Name' \
            --output text 2>/dev/null || echo "unknown")
          
          echo "Instance $INSTANCE_ID state: $INSTANCE_STATE"
          
          if [ "$INSTANCE_STATE" = "running" ]; then
            RUNNING_INSTANCES="$RUNNING_INSTANCES $INSTANCE_ID"
          fi
        done
        
        RUNNING_INSTANCES=$(echo "$RUNNING_INSTANCES" | xargs)  # Trim whitespace
        echo "Running instances: $RUNNING_INSTANCES"
        
        if [ -z "$RUNNING_INSTANCES" ]; then
          echo "‚ùå No running instances found!"
          exit 1
        fi
        
        # Get public IP addresses for running instances - FIXED: Proper formatting
        echo "=== Getting IP addresses for running instances ==="
        INSTANCE_IPS_RAW=$(aws ec2 describe-instances \
          --instance-ids $RUNNING_INSTANCES \
          --query 'Reservations[].Instances[?State.Name==`running`].PublicIpAddress' \
          --output text)
        
        # FIXED: Convert newlines and tabs to spaces, remove empty entries
        INSTANCE_IPS=$(echo "$INSTANCE_IPS_RAW" | tr '\n\t' ' ' | tr -s ' ' | xargs)
        
        echo "Public IPs (raw): $INSTANCE_IPS_RAW"
        echo "Public IPs (formatted): $INSTANCE_IPS"
        
        # If no public IPs, try private IPs
        if [ -z "$INSTANCE_IPS" ] || [ "$INSTANCE_IPS" = "None" ]; then
          echo "No public IPs found, trying private IPs..."
          INSTANCE_IPS_RAW=$(aws ec2 describe-instances \
            --instance-ids $RUNNING_INSTANCES \
            --query 'Reservations[].Instances[?State.Name==`running`].PrivateIpAddress' \
            --output text)
          
          # FIXED: Same formatting for private IPs
          INSTANCE_IPS=$(echo "$INSTANCE_IPS_RAW" | tr '\n\t' ' ' | tr -s ' ' | xargs)
          echo "Private IPs (formatted): $INSTANCE_IPS"
        fi
        
        if [ -z "$INSTANCE_IPS" ]; then
          echo "‚ùå No IP addresses found for running instances!"
          exit 1
        fi
        
        # FIXED: Validate IP format before storing
        echo "Validating IP addresses..."
        for IP in $INSTANCE_IPS; do
          if [[ $IP =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            echo "‚úÖ Valid IP: $IP"
          else
            echo "‚ùå Invalid IP format: $IP"
            exit 1
          fi
        done
        
        # Store IPs in environment for next step
        echo "INSTANCE_IPS=$INSTANCE_IPS" >> $GITHUB_ENV
        echo "‚úÖ Found instances with IPs: $INSTANCE_IPS"

    - name: Deploy Application to All Instances
      env:
        PRIVATE_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        # Save the private key to a PEM file
        echo "$PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem
        
        echo "Instance IPs to deploy to: $INSTANCE_IPS"
        
        # Validate that INSTANCE_IPS is properly formatted
        if [ -z "$INSTANCE_IPS" ]; then
          echo "‚ùå No instance IPs available for deployment"
          exit 1
        fi
        
        # Check IP count
        IP_COUNT=$(echo $INSTANCE_IPS | wc -w)
        echo "Number of IPs to deploy to: $IP_COUNT"
        
        # Check what files are available for deployment
        echo "=== Checking available files for deployment ==="
        echo "Current directory contents:"
        ls -la
        
        echo "App directory contents:"
        if [ -d "app" ]; then
          ls -la app/
        else
          echo "‚ùå App directory not found!"
          exit 1
        fi
        
        echo "Monitoring directory contents:"
        if [ -d "monitoring" ]; then
          ls -la monitoring/
          MONITORING_EXISTS=true
        else
          echo "‚ö†Ô∏è Monitoring directory not found - will skip monitoring setup"
          MONITORING_EXISTS=false
        fi
        
        SUCCESS_COUNT=0
        TOTAL_COUNT=0
        
        # Deploy to each instance
        for INSTANCE_IP in $INSTANCE_IPS; do
          echo "===================="
          echo "Deploying to instance: $INSTANCE_IP"
          echo "===================="
          
          TOTAL_COUNT=$((TOTAL_COUNT + 1))
          
          # Skip if IP is empty or "None"
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
            echo "Skipping empty or invalid IP: $INSTANCE_IP"
            continue
          fi
          
          # Additional IP validation
          if ! [[ $INSTANCE_IP =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            echo "‚ùå Invalid IP format: $INSTANCE_IP - skipping"
            continue
          fi
          
          # Retry logic for establishing SSH connection
          echo "Waiting for SSH connection to $INSTANCE_IP..."
          SSH_SUCCESS=false
          
          for i in {1..15}; do
            if ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ubuntu@$INSTANCE_IP "echo 'SSH connection successful'" 2>/dev/null; then
              echo "‚úÖ SSH connection established to $INSTANCE_IP!"
              SSH_SUCCESS=true
              break
            fi
            echo "Waiting for SSH... attempt $i/15"
            sleep 10
          done
          
          if [ "$SSH_SUCCESS" = false ]; then
            echo "‚ùå Failed to establish SSH connection to $INSTANCE_IP after 15 attempts"
            echo "Skipping this instance and continuing with others..."
            continue
          fi
          
          # Copy application files
          echo "Deploying application files to $INSTANCE_IP..."
          if ! scp -i private_key.pem -o StrictHostKeyChecking=no -r app/* ubuntu@$INSTANCE_IP:/tmp/ 2>/dev/null; then
            echo "‚ùå Failed to copy app files to $INSTANCE_IP"
            continue
          fi
          echo "‚úÖ App files copied successfully"
          
          # Copy monitoring files only if they exist, and make it non-blocking
          if [ "$MONITORING_EXISTS" = true ]; then
            echo "Copying monitoring files to $INSTANCE_IP..."
            if scp -i private_key.pem -o StrictHostKeyChecking=no -r monitoring/* ubuntu@$INSTANCE_IP:/tmp/ 2>/dev/null; then
              echo "‚úÖ Monitoring files copied successfully"
              MONITORING_DEPLOYED=true
            else
              echo "‚ö†Ô∏è Failed to copy monitoring files to $INSTANCE_IP (continuing anyway)"
              MONITORING_DEPLOYED=false
            fi
          else
            echo "‚ö†Ô∏è Skipping monitoring files (directory not found)"
            MONITORING_DEPLOYED=false
          fi
          
          # Deploy and configure application with ENHANCED ERROR HANDLING
          echo "Setting up web application on $INSTANCE_IP..."
          if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
            # Wait for LAMP stack setup to complete
            echo 'Waiting for LAMP stack installation to complete...'
            timeout 300 bash -c 'while [ ! -f /var/log/cloud-init-output.log ] || ! grep -q \"LAMP Stack installation completed\" /var/log/cloud-init-output.log; do
              echo \"Still waiting for LAMP stack...\"
              sleep 15
            done'
            
            # Check if Apache is currently running
            echo 'Checking Apache status before deployment...'
            sudo systemctl status apache2 --no-pager || echo 'Apache not running initially'
            
            # Backup existing Apache configuration
            echo 'Creating backup of current Apache setup...'
            sudo cp -r /var/www/html /var/www/html.backup.\$(date +%s) 2>/dev/null || echo 'No existing files to backup'
            
            # Move the PHP/CSS files to Apache's document root
            echo 'Moving application files...'
            sudo cp /tmp/*.php /var/www/html/ 2>/dev/null && echo 'PHP files copied' || echo 'No PHP files to copy'
            sudo cp /tmp/*.css /var/www/html/ 2>/dev/null && echo 'CSS files copied' || echo 'No CSS files to copy'
            
            # CRITICAL FIX: Set correct permissions BEFORE syntax check
            echo 'Setting file permissions...'
            sudo chown -R www-data:www-data /var/www/html/
            sudo chmod 755 /var/www/html/
            sudo chmod 644 /var/www/html/*.php 2>/dev/null || echo 'No PHP files to set permissions'
            sudo chmod 644 /var/www/html/*.css 2>/dev/null || echo 'No CSS files to set permissions'
            
            # ADDED: Validate PHP syntax before proceeding
            echo 'Validating PHP syntax...'
            PHP_SYNTAX_OK=true
            for phpfile in /var/www/html/*.php; do
              if [ -f \"\$phpfile\" ]; then
                if ! php -l \"\$phpfile\" >/dev/null 2>&1; then
                  echo \"‚ùå PHP syntax error in \$phpfile:\"
                  php -l \"\$phpfile\" || true
                  PHP_SYNTAX_OK=false
                fi
              fi
            done
            
            if [ \"\$PHP_SYNTAX_OK\" = \"true\" ]; then
              echo '‚úÖ All PHP files have valid syntax'
            else
              echo '‚ùå PHP syntax errors found - cannot proceed with deployment'
              exit 1
            fi
            
            # Set up monitoring only if files were successfully copied
            if [ '$MONITORING_DEPLOYED' = true ]; then
              echo 'Setting up monitoring...'
              sudo cp /tmp/cloudwatch-agent.json /opt/aws/amazon-cloudwatch-agent/etc/ 2>/dev/null || echo 'CloudWatch agent config copy failed'
              sudo cp /tmp/custom-metrics.sh /usr/local/bin/ 2>/dev/null || echo 'Custom metrics script copy failed'
              sudo chmod +x /usr/local/bin/custom-metrics.sh 2>/dev/null || echo 'Failed to make custom-metrics.sh executable'
              
              # Restart CloudWatch agent if config was updated
              sudo /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
                -a fetch-config -m ec2 -s -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json 2>/dev/null || echo 'CloudWatch agent restart failed'
            else
              echo 'Skipping monitoring setup (files not available)'
            fi
            
            # ADDED: Test Apache configuration before restart
            echo 'Testing Apache configuration...'
            if ! sudo apache2ctl configtest 2>/dev/null; then
              echo '‚ùå Apache configuration test failed:'
              sudo apache2ctl configtest 2>&1 || true
              echo 'This usually indicates a PHP or module configuration issue.'
              exit 1
            fi
            echo '‚úÖ Apache configuration is valid'
            
            # Restart Apache with better error handling
            echo 'Restarting Apache...'
            if sudo systemctl restart apache2; then
              echo '‚úÖ Apache restarted successfully'
            else
              echo '‚ùå Apache restart failed - checking logs...'
              sudo systemctl status apache2 --no-pager || true
              echo '--- Last 20 lines of Apache error log ---'
              sudo tail -20 /var/log/apache2/error.log || true
              echo '--- Checking for Apache processes ---'
              ps aux | grep apache2 || true
              
              # Try to start Apache manually for better error output
              echo 'Attempting manual Apache start...'
              sudo apache2ctl start 2>&1 || true
              exit 1
            fi
            
            # Wait a moment for Apache to fully start
            sleep 5
            
            # ENHANCED: Multiple health checks
            echo 'Testing web server health...'
            
            # Test 1: Check if Apache process is running
            if pgrep apache2 > /dev/null; then
              echo '‚úÖ Apache processes are running'
            else
              echo '‚ùå Apache processes not found'
              ps aux | grep apache2 || true
              exit 1
            fi
            
            # Test 2: Check if Apache is listening on port 80
            if netstat -tlnp | grep ':80 ' > /dev/null; then
              echo '‚úÖ Apache is listening on port 80'
            else
              echo '‚ùå Apache is not listening on port 80'
              echo 'Checking what is listening:'
              sudo netstat -tlnp | grep ':80' || echo 'Nothing listening on port 80'
              exit 1
            fi
            
            # Test 3: Test local HTTP connectivity with retries
            echo 'Testing local HTTP connectivity...'
            HTTP_SUCCESS=false
            for attempt in {1..10}; do
              if curl -s -m 5 http://localhost/ > /dev/null; then
                echo \"‚úÖ Local HTTP test passed (attempt \$attempt)\"
                HTTP_SUCCESS=true
                break
              else
                echo \"‚è≥ Local HTTP test failed, attempt \$attempt/10\"
                sleep 2
              fi
            done
            
            if [ \"\$HTTP_SUCCESS\" != \"true\" ]; then
              echo '‚ùå Local HTTP connectivity failed after 10 attempts'
              
              # Debug information
              echo '=== DEBUGGING INFORMATION ==='
              echo '--- Apache Status ---'
              sudo systemctl status apache2 --no-pager || true
              echo '--- Apache Error Log (last 30 lines) ---'
              sudo tail -30 /var/log/apache2/error.log || true
              echo '--- Apache Access Log (last 10 lines) ---'
              sudo tail -10 /var/log/apache2/access.log || true
              echo '--- Files in /var/www/html ---'
              ls -la /var/www/html/ || true
              echo '--- Apache Configuration Test ---'
              sudo apache2ctl configtest || true
              echo '--- Network Connections ---'
              sudo netstat -tlnp || true
              
              exit 1
            fi
            
            # Test 4: Test health.php specifically
            if curl -s -m 5 http://localhost/health.php | grep -q 'healthy\\|status' 2>/dev/null; then
              echo '‚úÖ Health check endpoint working'
            else
              echo '‚ö†Ô∏è Health check endpoint not working, testing index.php...'
              if curl -s -m 5 http://localhost/index.php > /dev/null; then
                echo '‚úÖ Index page working'
              else
                echo '‚ùå Index page also not working'
                echo 'Raw response from localhost:'
                curl -v -m 10 http://localhost/ 2>&1 || true
                exit 1
              fi
            fi
            
            # Confirm files are in place
            echo \"‚úÖ Application deployment completed successfully on $INSTANCE_IP!\"
            echo \"Files in /var/www/html/:\"
            ls -la /var/www/html/
            
            echo '=== FINAL STATUS CHECK ==='
            sudo systemctl is-active apache2 && echo 'Apache is active' || echo 'Apache is not active'
            ps aux | grep apache2 | grep -v grep | wc -l | xargs echo 'Apache processes:'
            
          "; then
            echo "‚úÖ Successfully deployed to $INSTANCE_IP"
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          else
            echo "‚ùå Deployment failed on $INSTANCE_IP"
            
            # Get debug information on failure
            echo "=== DEBUGGING FAILED DEPLOYMENT ==="
            ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
              echo 'Apache status:'
              sudo systemctl status apache2 --no-pager || true
              echo 'Apache error log (last 20 lines):'
              sudo tail -20 /var/log/apache2/error.log || true
              echo 'Files in /var/www/html:'
              ls -la /var/www/html/ || true
              echo 'PHP syntax check:'
              for phpfile in /var/www/html/*.php; do
                if [ -f \"\$phpfile\" ]; then
                  echo \"Checking \$phpfile:\"
                  php -l \"\$phpfile\" || true
                fi
              done
            " || echo "Could not retrieve debug information"
          fi
          
          echo "Finished deployment attempt to $INSTANCE_IP"
        done
        
        # Clean up local PEM file
        rm -f private_key.pem
        
        # Final deployment summary
        echo "===================="
        echo "DEPLOYMENT SUMMARY"
        echo "===================="
        echo "Total instances: $TOTAL_COUNT"
        echo "Successful deployments: $SUCCESS_COUNT"
        echo "Failed deployments: $((TOTAL_COUNT - SUCCESS_COUNT))"
        
        if [ $SUCCESS_COUNT -gt 0 ]; then
          echo "üéâ Application deployed successfully to $SUCCESS_COUNT instance(s)!"
          echo "üåê Access your load-balanced application at: http://$LOAD_BALANCER_DNS"
          if [ "$MONITORING_EXISTS" = false ]; then
            echo "‚ö†Ô∏è Note: Monitoring setup was skipped due to missing files"
          fi
        else
          echo "‚ùå All deployments failed!"
          exit 1
        fi

  health_check:
    name: 'Health Check and Monitoring Setup'
    runs-on: ubuntu-latest
    needs: [terraform, deploy]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Load Balancer Health Checks
      env:
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        echo "Waiting for load balancer health checks to pass..."
        sleep 180
        
        # Test load balancer endpoint with more attempts
        for i in {1..15}; do
          echo "Testing load balancer... attempt $i/15"
          if curl -f -s -m 10 "http://$LOAD_BALANCER_DNS/health.php" > /dev/null; then
            echo "‚úÖ Load balancer health check passed!"
            echo "üåê Application is healthy at: http://$LOAD_BALANCER_DNS"
            break
          elif curl -f -s -m 10 "http://$LOAD_BALANCER_DNS/" > /dev/null; then
            echo "‚úÖ Main application page is accessible!"
            echo "üåê Application is accessible at: http://$LOAD_BALANCER_DNS"
            break
          else
            echo "‚è≥ Waiting for health check... attempt $i/15"
            if [ $i -eq 15 ]; then
              echo "‚ùå Health check failed after 15 attempts"
              echo "üîç Let's check what's available..."
              
              # Try to get more information about the failure
              echo "Load balancer DNS: $LOAD_BALANCER_DNS"
              
              # Test basic connectivity
              if ping -c 3 "$LOAD_BALANCER_DNS" > /dev/null 2>&1; then
                echo "‚úÖ Load balancer DNS resolves and is reachable"
              else
                echo "‚ùå Load balancer DNS does not resolve or is not reachable"
              fi
              
              # Try HTTP request with more details
              echo "Detailed HTTP test:"
              curl -v -m 15 "http://$LOAD_BALANCER_DNS/" || echo "Detailed HTTP test failed"
              
              echo "‚ö†Ô∏è Application may be accessible but health checks are failing"
              echo "üåê Try accessing: http://$LOAD_BALANCER_DNS"
            else
              sleep 30
            fi
          fi
        done
        
        echo "Deployment completed! üöÄ"
        echo ""
        echo "=== FINAL DEPLOYMENT STATUS ==="
        echo "üåê Application URL: http://$LOAD_BALANCER_DNS"
        echo "üîç Health Check: http://$LOAD_BALANCER_DNS/health.php"
        echo "üìä AWS Console: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}"