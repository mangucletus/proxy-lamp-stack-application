# GitHub Actions workflow to deploy a Proxy LAMP Stack application on AWS EC2 with Load Balancer

name: Deploy Proxy LAMP Stack with Load Balancer

# Event triggers
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Environment variables shared across all jobs
env:
  AWS_REGION: eu-central-1
  TF_VERSION: 1.5.0
  DEPLOYMENT_BUCKET: proxy-lamp-deployment-cletusmangu-1749764715

jobs:
  terraform:
    name: 'Terraform Infrastructure'
    runs-on: ubuntu-latest
    outputs:
      load_balancer_dns: ${{ steps.terraform-output.outputs.load_balancer_dns }}
      autoscaling_group_name: ${{ steps.terraform-output.outputs.autoscaling_group_name }}
    
    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      run: terraform init

    - name: Terraform Validate
      run: terraform validate

    - name: Terraform Plan
      if: github.event_name == 'pull_request'
      run: |
        terraform plan \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -no-color
      continue-on-error: true

    - name: Terraform Apply
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        terraform apply \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -auto-approve

    - name: Get Terraform Outputs
      if: github.ref == 'refs/heads/main'
      id: terraform-output
      run: |
        echo "load_balancer_dns=$(terraform output -raw load_balancer_dns)" >> $GITHUB_OUTPUT
        echo "autoscaling_group_name=$(terraform output -raw autoscaling_group_name)" >> $GITHUB_OUTPUT

  deploy:
    name: 'Deploy Application to Load Balanced Infrastructure'
    runs-on: ubuntu-latest
    needs: terraform
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Infrastructure to be Ready
      run: |
        echo "Waiting for Auto Scaling Group instances to be fully initialized..."
        sleep 300  # FIXED: Increased from 120 to 300 seconds (5 minutes)

    - name: Get Instance IPs from Auto Scaling Group
      id: get-instances
      env:
        ASG_NAME: ${{ needs.terraform.outputs.autoscaling_group_name }}
      run: |
        echo "Getting instance IPs from Auto Scaling Group: $ASG_NAME"
        
        # FIXED: Wait for instances to appear in ASG (up to 10 minutes)
        echo "=== Waiting for instances to appear in ASG ==="
        for attempt in {1..20}; do
          ALL_INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --query 'AutoScalingGroups[0].Instances[*].InstanceId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$ALL_INSTANCE_IDS" ] && [ "$ALL_INSTANCE_IDS" != "None" ]; then
            echo "‚úÖ Found instances in ASG: $ALL_INSTANCE_IDS"
            break
          else
            echo "‚è≥ Waiting for instances in ASG... attempt $attempt/20"
            sleep 30
          fi
          
          if [ $attempt -eq 20 ]; then
            echo "‚ùå No instances found in ASG after 10 minutes"
            echo "Checking ASG configuration..."
            aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "$ASG_NAME" \
              --query 'AutoScalingGroups[0].{MinSize:MinSize,MaxSize:MaxSize,DesiredCapacity:DesiredCapacity,Instances:Instances}' || echo "Could not get ASG info"
            exit 1
          fi
        done
        
        echo "=== All instances in ASG ==="
        aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names "$ASG_NAME" \
          --query 'AutoScalingGroups[0].Instances[*].{InstanceId:InstanceId,State:LifecycleState,Health:HealthStatus}' \
          --output table
        
        # FIXED: Wait for instances to be in Running state (up to 15 minutes)
        echo "=== Waiting for instances to be in running state ==="
        RUNNING_INSTANCES=""
        for attempt in {1..30}; do
          RUNNING_INSTANCES=""
          for INSTANCE_ID in $ALL_INSTANCE_IDS; do
            INSTANCE_STATE=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text 2>/dev/null || echo "unknown")
            
            echo "Instance $INSTANCE_ID state: $INSTANCE_STATE"
            
            if [ "$INSTANCE_STATE" = "running" ]; then
              RUNNING_INSTANCES="$RUNNING_INSTANCES $INSTANCE_ID"
            fi
          done
          
          RUNNING_INSTANCES=$(echo "$RUNNING_INSTANCES" | xargs)
          
          if [ -n "$RUNNING_INSTANCES" ]; then
            echo "‚úÖ Found running instances: $RUNNING_INSTANCES"
            break
          else
            echo "‚è≥ Waiting for running instances... attempt $attempt/30"
            sleep 30
          fi
          
          if [ $attempt -eq 30 ]; then
            echo "‚ùå No running instances found after 15 minutes"
            exit 1
          fi
        done
        
        # Get IP addresses for running instances
        echo "=== Getting IP addresses for running instances ==="
        INSTANCE_IPS_RAW=$(aws ec2 describe-instances \
          --instance-ids $RUNNING_INSTANCES \
          --query 'Reservations[].Instances[?State.Name==`running`].PublicIpAddress' \
          --output text)
        
        INSTANCE_IPS=$(echo "$INSTANCE_IPS_RAW" | tr '\n\t' ' ' | tr -s ' ' | xargs)
        
        echo "Public IPs: $INSTANCE_IPS"
        
        # If no public IPs, try private IPs
        if [ -z "$INSTANCE_IPS" ] || [ "$INSTANCE_IPS" = "None" ]; then
          echo "No public IPs found, trying private IPs..."
          INSTANCE_IPS_RAW=$(aws ec2 describe-instances \
            --instance-ids $RUNNING_INSTANCES \
            --query 'Reservations[].Instances[?State.Name==`running`].PrivateIpAddress' \
            --output text)
          
          INSTANCE_IPS=$(echo "$INSTANCE_IPS_RAW" | tr '\n\t' ' ' | tr -s ' ' | xargs)
          echo "Private IPs: $INSTANCE_IPS"
        fi
        
        # Validate IPs
        if [ -z "$INSTANCE_IPS" ]; then
          echo "‚ùå No IP addresses found for running instances!"
          exit 1
        fi
        
        echo "INSTANCE_IPS=$INSTANCE_IPS" >> $GITHUB_ENV
        echo "‚úÖ Found instances with IPs: $INSTANCE_IPS"

    - name: Deploy Application to All Instances
      env:
        PRIVATE_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        echo "$PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem
        
        echo "Instance IPs to deploy to: $INSTANCE_IPS"
        
        if [ -z "$INSTANCE_IPS" ]; then
          echo "‚ùå No instance IPs available for deployment"
          exit 1
        fi
        
        IP_COUNT=$(echo $INSTANCE_IPS | wc -w)
        echo "Number of IPs to deploy to: $IP_COUNT"
        
        # Check application files
        echo "=== Checking available files for deployment ==="
        if [ ! -d "app" ]; then
          echo "‚ùå App directory not found!"
          exit 1
        fi
        
        ls -la app/
        
        if [ -d "monitoring" ]; then
          MONITORING_EXISTS=true
        else
          echo "‚ö†Ô∏è Monitoring directory not found - will skip monitoring setup"
          MONITORING_EXISTS=false
        fi
        
        SUCCESS_COUNT=0
        TOTAL_COUNT=0
        
        # Deploy to each instance
        for INSTANCE_IP in $INSTANCE_IPS; do
          echo "===================="
          echo "Deploying to instance: $INSTANCE_IP"
          echo "===================="
          
          TOTAL_COUNT=$((TOTAL_COUNT + 1))
          
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
            echo "Skipping empty or invalid IP: $INSTANCE_IP"
            continue
          fi
          
          # FIXED: Wait for SSH with longer timeout (up to 20 minutes)
          echo "Waiting for SSH connection to $INSTANCE_IP..."
          SSH_SUCCESS=false
          
          for i in {1..40}; do
            if timeout 30 ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ubuntu@$INSTANCE_IP "echo 'SSH connection successful'" 2>/dev/null; then
              echo "‚úÖ SSH connection established to $INSTANCE_IP!"
              SSH_SUCCESS=true
              break
            fi
            echo "Waiting for SSH... attempt $i/40"
            sleep 30
          done
          
          if [ "$SSH_SUCCESS" = false ]; then
            echo "‚ùå Failed to establish SSH connection to $INSTANCE_IP after 20 minutes"
            echo "Checking instance status..."
            
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=ip-address,Values=$INSTANCE_IP" \
              --query 'Reservations[0].Instances[0].InstanceId' \
              --output text 2>/dev/null || echo "unknown")
            
            if [ "$INSTANCE_ID" != "unknown" ] && [ "$INSTANCE_ID" != "None" ]; then
              echo "Instance ID: $INSTANCE_ID"
              aws ec2 describe-instance-status --instance-ids "$INSTANCE_ID" || echo "Could not get instance status"
            fi
            continue
          fi
          
          # FIXED: Wait for LAMP stack to be ready
          echo "Waiting for LAMP stack setup to complete on $INSTANCE_IP..."
          LAMP_READY=false
          
          for attempt in {1..40}; do
            if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "[ -f /tmp/lamp-setup-complete ]" 2>/dev/null; then
              echo "‚úÖ LAMP stack setup completed on $INSTANCE_IP"
              LAMP_READY=true
              break
            else
              echo "‚è≥ Waiting for LAMP stack setup... attempt $attempt/40"
              sleep 30
            fi
          done
          
          if [ "$LAMP_READY" = false ]; then
            echo "‚ùå LAMP stack setup did not complete on $INSTANCE_IP"
            echo "Checking setup logs..."
            ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
              echo '=== User Data Log (last 50 lines) ==='
              tail -50 /var/log/user-data.log 2>/dev/null || echo 'User data log not found'
              echo '=== Cloud Init Output (last 30 lines) ==='
              tail -30 /var/log/cloud-init-output.log 2>/dev/null || echo 'Cloud init log not found'
              echo '=== Apache Status ==='
              systemctl status apache2 --no-pager || echo 'Apache status unknown'
            " || echo "Could not retrieve debug information"
            continue
          fi
          
          # Test basic connectivity before deploying app
          echo "Testing basic web server on $INSTANCE_IP..."
          if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "curl -s -f http://localhost/ > /dev/null" 2>/dev/null; then
            echo "‚úÖ Web server is responding on $INSTANCE_IP"
          else
            echo "‚ùå Web server is not responding on $INSTANCE_IP"
            continue
          fi
          
          # Copy application files
          echo "Deploying application files to $INSTANCE_IP..."
          if scp -i private_key.pem -o StrictHostKeyChecking=no -r app/* ubuntu@$INSTANCE_IP:/tmp/ 2>/dev/null; then
            echo "‚úÖ App files copied successfully"
          else
            echo "‚ùå Failed to copy app files to $INSTANCE_IP"
            continue
          fi
          
          # Copy monitoring files if they exist
          if [ "$MONITORING_EXISTS" = true ]; then
            echo "Copying monitoring files to $INSTANCE_IP..."
            if scp -i private_key.pem -o StrictHostKeyChecking=no -r monitoring/* ubuntu@$INSTANCE_IP:/tmp/ 2>/dev/null; then
              echo "‚úÖ Monitoring files copied successfully"
              MONITORING_DEPLOYED=true
            else
              echo "‚ö†Ô∏è Failed to copy monitoring files to $INSTANCE_IP (continuing anyway)"
              MONITORING_DEPLOYED=false
            fi
          else
            MONITORING_DEPLOYED=false
          fi
          
          # FIXED: Deploy application with comprehensive error handling
          echo "Setting up web application on $INSTANCE_IP..."
          if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
            echo 'Installing application files...'
            
            # Backup existing files
            sudo cp -r /var/www/html /var/www/html.backup.\$(date +%s) 2>/dev/null || echo 'No existing files to backup'
            
            # Copy new files
            sudo cp /tmp/*.php /var/www/html/ 2>/dev/null && echo 'PHP files copied' || echo 'No PHP files found'
            sudo cp /tmp/*.css /var/www/html/ 2>/dev/null && echo 'CSS files copied' || echo 'No CSS files found'
            
            # Set permissions
            sudo chown -R www-data:www-data /var/www/html/
            sudo chmod 755 /var/www/html/
            sudo chmod 644 /var/www/html/*.php 2>/dev/null || echo 'No PHP files to set permissions'
            sudo chmod 644 /var/www/html/*.css 2>/dev/null || echo 'No CSS files to set permissions'
            
            # Validate PHP syntax
            echo 'Validating PHP syntax...'
            PHP_SYNTAX_OK=true
            for phpfile in /var/www/html/*.php; do
              if [ -f \"\$phpfile\" ]; then
                if ! php -l \"\$phpfile\" >/dev/null 2>&1; then
                  echo \"‚ùå PHP syntax error in \$phpfile\"
                  php -l \"\$phpfile\" || true
                  PHP_SYNTAX_OK=false
                fi
              fi
            done
            
            if [ \"\$PHP_SYNTAX_OK\" != \"true\" ]; then
              echo '‚ùå PHP syntax errors found - cannot proceed with deployment'
              exit 1
            fi
            echo '‚úÖ All PHP files have valid syntax'
            
            # Set up monitoring only if files were successfully copied
            if [ '$MONITORING_DEPLOYED' = true ]; then
              echo 'Setting up monitoring...'
              sudo cp /tmp/cloudwatch-agent.json /opt/aws/amazon-cloudwatch-agent/etc/ 2>/dev/null || echo 'CloudWatch agent config copy failed'
              sudo cp /tmp/custom-metrics.sh /usr/local/bin/ 2>/dev/null || echo 'Custom metrics script copy failed'
              sudo chmod +x /usr/local/bin/custom-metrics.sh 2>/dev/null || echo 'Failed to make custom-metrics.sh executable'
              
              # Restart CloudWatch agent if config was updated
              sudo /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
                -a fetch-config -m ec2 -s -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json 2>/dev/null || echo 'CloudWatch agent restart failed'
            else
              echo 'Skipping monitoring setup (files not available)'
            fi
            
            # Test Apache configuration
            echo 'Testing Apache configuration...'
            if ! sudo apache2ctl configtest 2>/dev/null; then
              echo '‚ùå Apache configuration test failed'
              sudo apache2ctl configtest 2>&1 || true
              exit 1
            fi
            echo '‚úÖ Apache configuration is valid'
            
            # Restart Apache
            echo 'Restarting Apache...'
            if sudo systemctl restart apache2; then
              echo '‚úÖ Apache restarted successfully'
            else
              echo '‚ùå Apache restart failed'
              sudo systemctl status apache2 --no-pager || true
              exit 1
            fi
            
            sleep 5
            
            # Test final connectivity
            echo 'Testing final connectivity...'
            HTTP_SUCCESS=false
            for attempt in {1..10}; do
              if curl -s -f http://localhost/ > /dev/null; then
                echo \"‚úÖ Local HTTP test passed (attempt \$attempt)\"
                HTTP_SUCCESS=true
                break
              else
                echo \"‚è≥ Local HTTP test failed, attempt \$attempt/10\"
                sleep 2
              fi
            done
            
            if [ \"\$HTTP_SUCCESS\" != \"true\" ]; then
              echo '‚ùå Application is not responding after deployment'
              echo '=== DEBUGGING INFORMATION ==='
              sudo systemctl status apache2 --no-pager || true
              echo '--- Apache Error Log (last 20 lines) ---'
              sudo tail -20 /var/log/apache2/error.log || true
              echo '--- Files in /var/www/html ---'
              ls -la /var/www/html/ || true
              exit 1
            fi
            
            echo '‚úÖ Application deployment successful'
          "; then
            echo "‚úÖ Successfully deployed to $INSTANCE_IP"
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          else
            echo "‚ùå Deployment failed on $INSTANCE_IP"
          fi
        done
        
        rm -f private_key.pem
        
        echo "===================="
        echo "DEPLOYMENT SUMMARY"
        echo "===================="
        echo "Total instances: $TOTAL_COUNT"
        echo "Successful deployments: $SUCCESS_COUNT"
        echo "Failed deployments: $((TOTAL_COUNT - SUCCESS_COUNT))"
        
        if [ $SUCCESS_COUNT -gt 0 ]; then
          echo "üéâ Application deployed successfully to $SUCCESS_COUNT instance(s)!"
          echo "üåê Access your load-balanced application at: http://$LOAD_BALANCER_DNS"
        else
          echo "‚ùå All deployments failed!"
          exit 1
        fi

  health_check:
    name: 'Health Check and Monitoring Setup'
    runs-on: ubuntu-latest
    needs: [terraform, deploy]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Load Balancer Health Checks
      env:
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        echo "Waiting for load balancer health checks to pass..."
        sleep 300  # FIXED: Increased wait time to 5 minutes
        
        # Test load balancer endpoint with more attempts
        for i in {1..20}; do
          echo "Testing load balancer... attempt $i/20"
          if curl -f -s -m 10 "http://$LOAD_BALANCER_DNS/health.php" > /dev/null; then
            echo "‚úÖ Load balancer health check passed!"
            echo "üåê Application is healthy at: http://$LOAD_BALANCER_DNS"
            break
          elif curl -f -s -m 10 "http://$LOAD_BALANCER_DNS/" > /dev/null; then
            echo "‚úÖ Main application page is accessible!"
            echo "üåê Application is accessible at: http://$LOAD_BALANCER_DNS"
            break
          else
            echo "‚è≥ Waiting for health check... attempt $i/20"
            if [ $i -eq 20 ]; then
              echo "‚ùå Health check failed after 20 attempts"
              echo "üîç Let's check what's available..."
              
              echo "Load balancer DNS: $LOAD_BALANCER_DNS"
              
              # Test basic connectivity
              if ping -c 3 "$LOAD_BALANCER_DNS" > /dev/null 2>&1; then
                echo "‚úÖ Load balancer DNS resolves and is reachable"
              else
                echo "‚ùå Load balancer DNS does not resolve or is not reachable"
              fi
              
              # Try HTTP request with more details
              echo "Detailed HTTP test:"
              curl -v -m 15 "http://$LOAD_BALANCER_DNS/" || echo "Detailed HTTP test failed"
              
              echo "‚ö†Ô∏è Application may be accessible but health checks are failing"
              echo "üåê Try accessing: http://$LOAD_BALANCER_DNS"
            else
              sleep 60  # FIXED: Increased sleep between attempts
            fi
          fi
        done
        
        echo "Deployment completed! üöÄ"
        echo ""
        echo "=== FINAL DEPLOYMENT STATUS ==="
        echo "üåê Application URL: http://$LOAD_BALANCER_DNS"
        echo "üîç Health Check: http://$LOAD_BALANCER_DNS/health.php"
        echo "üìä AWS Console: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}"