# GitHub Actions workflow to deploy a Proxy LAMP Stack application on AWS EC2 with Load Balancer

name: Deploy Proxy LAMP Stack with Load Balancer

# Event triggers
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Environment variables shared across all jobs
env:
  AWS_REGION: eu-central-1
  TF_VERSION: 1.5.0
  DEPLOYMENT_BUCKET: proxy-lamp-deployment-cletusmangu-1749764715

jobs:
  terraform:
    name: 'Terraform Infrastructure'
    runs-on: ubuntu-latest
    outputs:
      load_balancer_dns: ${{ steps.terraform-output.outputs.load_balancer_dns }}
      autoscaling_group_name: ${{ steps.terraform-output.outputs.autoscaling_group_name }}
    
    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # FIXED: Clean up any existing state issues
    - name: Clean Terraform State
      run: |
        echo "Cleaning up potential state issues..."
        rm -rf .terraform/
        rm -f .terraform.lock.hcl
        
        # Format all files to ensure syntax is correct
        terraform fmt -recursive .
        echo "âœ… Terraform files formatted"

    - name: Terraform Init
      run: |
        echo "Initializing Terraform..."
        terraform init -reconfigure
        echo "âœ… Terraform initialized"

    - name: Terraform Validate
      run: |
        echo "Validating Terraform configuration..."
        terraform validate
        echo "âœ… Terraform configuration is valid"

    - name: Terraform Plan
      if: github.event_name == 'pull_request'
      run: |
        terraform plan \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -no-color
      continue-on-error: true

    - name: Terraform Apply
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        terraform apply \
          -var="public_key=${{ secrets.EC2_PUBLIC_KEY }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -auto-approve

    - name: Get Terraform Outputs
      if: github.ref == 'refs/heads/main'
      id: terraform-output
      run: |
        echo "load_balancer_dns=$(terraform output -raw load_balancer_dns)" >> $GITHUB_OUTPUT
        echo "autoscaling_group_name=$(terraform output -raw autoscaling_group_name)" >> $GITHUB_OUTPUT

  deploy:
    name: 'Deploy Application to Load Balanced Infrastructure'
    runs-on: ubuntu-latest
    needs: terraform
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Infrastructure to be Ready
      run: |
        echo "Waiting for Auto Scaling Group instances to be ready..."
        sleep 180  # FIXED: Reduced initial wait to 3 minutes

    - name: Get Instance IPs from Auto Scaling Group
      id: get-instances
      env:
        ASG_NAME: ${{ needs.terraform.outputs.autoscaling_group_name }}
      run: |
        echo "Getting instance IPs from Auto Scaling Group: $ASG_NAME"
        
        # FIXED: Wait for instances to appear in ASG (up to 15 minutes)
        echo "=== Waiting for instances to appear in ASG ==="
        for attempt in {1..30}; do
          ALL_INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --query 'AutoScalingGroups[0].Instances[*].InstanceId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$ALL_INSTANCE_IDS" ] && [ "$ALL_INSTANCE_IDS" != "None" ]; then
            echo "âœ… Found instances in ASG: $ALL_INSTANCE_IDS"
            break
          else
            echo "â³ Waiting for instances in ASG... attempt $attempt/30"
            sleep 30
          fi
          
          if [ $attempt -eq 30 ]; then
            echo "âŒ No instances found in ASG after 15 minutes"
            exit 1
          fi
        done
        
        # FIXED: Wait for instances to be in Running state (up to 10 minutes)
        echo "=== Waiting for instances to be in running state ==="
        RUNNING_INSTANCES=""
        for attempt in {1..20}; do
          RUNNING_INSTANCES=""
          for INSTANCE_ID in $ALL_INSTANCE_IDS; do
            INSTANCE_STATE=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text 2>/dev/null || echo "unknown")
            
            echo "Instance $INSTANCE_ID state: $INSTANCE_STATE"
            
            if [ "$INSTANCE_STATE" = "running" ]; then
              RUNNING_INSTANCES="$RUNNING_INSTANCES $INSTANCE_ID"
            fi
          done
          
          RUNNING_INSTANCES=$(echo "$RUNNING_INSTANCES" | xargs)
          
          if [ -n "$RUNNING_INSTANCES" ]; then
            echo "âœ… Found running instances: $RUNNING_INSTANCES"
            break
          else
            echo "â³ Waiting for running instances... attempt $attempt/20"
            sleep 30
          fi
          
          if [ $attempt -eq 20 ]; then
            echo "âŒ No running instances found after 10 minutes"
            exit 1
          fi
        done
        
        # Get IP addresses for running instances
        echo "=== Getting IP addresses for running instances ==="
        INSTANCE_IPS_RAW=$(aws ec2 describe-instances \
          --instance-ids $RUNNING_INSTANCES \
          --query 'Reservations[].Instances[?State.Name==`running`].PublicIpAddress' \
          --output text)
        
        INSTANCE_IPS=$(echo "$INSTANCE_IPS_RAW" | tr '\n\t' ' ' | tr -s ' ' | xargs)
        
        echo "Public IPs: $INSTANCE_IPS"
        
        # Validate IPs
        if [ -z "$INSTANCE_IPS" ]; then
          echo "âŒ No IP addresses found for running instances!"
          exit 1
        fi
        
        echo "INSTANCE_IPS=$INSTANCE_IPS" >> $GITHUB_ENV
        echo "âœ… Found instances with IPs: $INSTANCE_IPS"

    - name: Deploy Application to All Instances
      env:
        PRIVATE_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        echo "$PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem
        
        echo "Instance IPs to deploy to: $INSTANCE_IPS"
        
        if [ -z "$INSTANCE_IPS" ]; then
          echo "âŒ No instance IPs available for deployment"
          exit 1
        fi
        
        IP_COUNT=$(echo $INSTANCE_IPS | wc -w)
        echo "Number of IPs to deploy to: $IP_COUNT"
        
        # Check application files
        echo "=== Checking available files for deployment ==="
        if [ ! -d "app" ]; then
          echo "âŒ App directory not found!"
          exit 1
        fi
        
        ls -la app/
        
        SUCCESS_COUNT=0
        TOTAL_COUNT=0
        
        # Deploy to each instance
        for INSTANCE_IP in $INSTANCE_IPS; do
          echo "===================="
          echo "Deploying to instance: $INSTANCE_IP"
          echo "===================="
          
          TOTAL_COUNT=$((TOTAL_COUNT + 1))
          
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
            echo "Skipping empty or invalid IP: $INSTANCE_IP"
            continue
          fi
          
          # FIXED: Wait for SSH with reasonable timeout (up to 10 minutes)
          echo "Waiting for SSH connection to $INSTANCE_IP..."
          SSH_SUCCESS=false
          
          for i in {1..20}; do
            if timeout 15 ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ubuntu@$INSTANCE_IP "echo 'SSH connection successful'" 2>/dev/null; then
              echo "âœ… SSH connection established to $INSTANCE_IP!"
              SSH_SUCCESS=true
              break
            fi
            echo "Waiting for SSH... attempt $i/20"
            sleep 30
          done
          
          if [ "$SSH_SUCCESS" = false ]; then
            echo "âŒ Failed to establish SSH connection to $INSTANCE_IP after 10 minutes"
            continue
          fi
          
          # FIXED: Wait for basic LAMP stack (reduced timeout)
          echo "Checking if basic LAMP stack is ready on $INSTANCE_IP..."
          LAMP_READY=false
          
          for attempt in {1..20}; do
            # FIXED: Check if Apache is responding instead of looking for file
            if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "curl -s -f http://localhost/ > /dev/null" 2>/dev/null; then
              echo "âœ… Apache is responding on $INSTANCE_IP"
              LAMP_READY=true
              break
            else
              echo "â³ Waiting for Apache to respond... attempt $attempt/20"
              sleep 15
            fi
          done
          
          if [ "$LAMP_READY" = false ]; then
            echo "âŒ Apache is not responding on $INSTANCE_IP"
            echo "Checking server status..."
            ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
              echo '=== System Status ==='
              systemctl status apache2 --no-pager || echo 'Apache status unknown'
              echo '=== User Data Log (last 20 lines) ==='
              tail -20 /var/log/user-data.log 2>/dev/null || echo 'User data log not found'
            " || echo "Could not retrieve debug information"
            continue
          fi
          
          # FIXED: Copy application files with error handling
          echo "Deploying application files to $INSTANCE_IP..."
          if scp -i private_key.pem -o StrictHostKeyChecking=no -r app/* ubuntu@$INSTANCE_IP:/tmp/ 2>/dev/null; then
            echo "âœ… App files copied successfully"
          else
            echo "âŒ Failed to copy app files to $INSTANCE_IP"
            continue
          fi
          
          # FIXED: Deploy application with better error handling
          echo "Setting up web application on $INSTANCE_IP..."
          if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
            set -e
            echo 'Deploying application files...'
            
            # Backup existing files
            sudo cp -r /var/www/html /var/www/html.backup.\$(date +%s) 2>/dev/null || echo 'No existing files to backup'
            
            # Copy new files
            sudo cp /tmp/*.php /var/www/html/ 2>/dev/null && echo 'PHP files copied' || echo 'No PHP files found'
            sudo cp /tmp/*.css /var/www/html/ 2>/dev/null && echo 'CSS files copied' || echo 'No CSS files found'
            
            # Set permissions
            sudo chown -R www-data:www-data /var/www/html/
            sudo chmod 755 /var/www/html/
            sudo chmod 644 /var/www/html/*.php 2>/dev/null || echo 'No PHP files to set permissions'
            sudo chmod 644 /var/www/html/*.css 2>/dev/null || echo 'No CSS files to set permissions'
            
            # Validate PHP syntax
            echo 'Validating PHP syntax...'
            for phpfile in /var/www/html/*.php; do
              if [ -f \"\$phpfile\" ]; then
                if ! php -l \"\$phpfile\" >/dev/null 2>&1; then
                  echo \"âŒ PHP syntax error in \$phpfile\"
                  php -l \"\$phpfile\" || true
                  exit 1
                fi
              fi
            done
            echo 'âœ… All PHP files have valid syntax'
            
            # Test Apache configuration
            echo 'Testing Apache configuration...'
            if ! sudo apache2ctl configtest 2>/dev/null; then
              echo 'âŒ Apache configuration test failed'
              sudo apache2ctl configtest 2>&1 || true
              exit 1
            fi
            echo 'âœ… Apache configuration is valid'
            
            # Restart Apache
            echo 'Restarting Apache...'
            if sudo systemctl reload apache2; then
              echo 'âœ… Apache reloaded successfully'
            else
              echo 'Apache reload failed, trying restart...'
              if sudo systemctl restart apache2; then
                echo 'âœ… Apache restarted successfully'
              else
                echo 'âŒ Apache restart failed'
                sudo systemctl status apache2 --no-pager || true
                exit 1
              fi
            fi
            
            sleep 3
            
            # Test final connectivity
            echo 'Testing final connectivity...'
            for attempt in {1..10}; do
              if curl -s -f http://localhost/ > /dev/null; then
                echo \"âœ… Application is responding (attempt \$attempt)\"
                break
              else
                echo \"â³ Application test failed, attempt \$attempt/10\"
                if [ \$attempt -eq 10 ]; then
                  echo 'âŒ Application is not responding after deployment'
                  exit 1
                fi
                sleep 2
              fi
            done
            
            echo 'âœ… Application deployment successful'
          "; then
            echo "âœ… Successfully deployed to $INSTANCE_IP"
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          else
            echo "âŒ Deployment failed on $INSTANCE_IP"
          fi
        done
        
        rm -f private_key.pem
        
        echo "===================="
        echo "DEPLOYMENT SUMMARY"
        echo "===================="
        echo "Total instances: $TOTAL_COUNT"
        echo "Successful deployments: $SUCCESS_COUNT"
        echo "Failed deployments: $((TOTAL_COUNT - SUCCESS_COUNT))"
        
        if [ $SUCCESS_COUNT -gt 0 ]; then
          echo "ğŸ‰ Application deployed successfully to $SUCCESS_COUNT instance(s)!"
          echo "ğŸŒ Access your load-balanced application at: http://$LOAD_BALANCER_DNS"
          
          # FIXED: Update ASG health check type to ELB after successful deployment
          echo "Updating Auto Scaling Group health check type to ELB..."
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name "${{ needs.terraform.outputs.autoscaling_group_name }}" \
            --health-check-type ELB \
            --health-check-grace-period 300 || echo "Warning: Could not update health check type"
        else
          echo "âŒ All deployments failed!"
          exit 1
        fi

  health_check:
    name: 'Health Check and Monitoring Setup'
    runs-on: ubuntu-latest
    needs: [terraform, deploy]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Load Balancer Health Checks
      env:
        LOAD_BALANCER_DNS: ${{ needs.terraform.outputs.load_balancer_dns }}
      run: |
        echo "Waiting for load balancer and application to be fully ready..."
        sleep 120  # FIXED: Reduced initial wait time
        
        echo "Load balancer DNS: $LOAD_BALANCER_DNS"
        
        # FIXED: Test load balancer endpoint with more reasonable attempts
        HEALTH_SUCCESS=false
        APP_SUCCESS=false
        
        for i in {1..30}; do
          echo "Testing load balancer... attempt $i/30"
          
          # Test health endpoint
          if curl -f -s -m 15 "http://$LOAD_BALANCER_DNS/health.php" > /dev/null 2>&1; then
            echo "âœ… Health endpoint is responding!"
            HEALTH_SUCCESS=true
          fi
          
          # Test main application
          if curl -f -s -m 15 "http://$LOAD_BALANCER_DNS/" > /dev/null 2>&1; then
            echo "âœ… Main application is responding!"
            APP_SUCCESS=true
          fi
          
          # If both are working, we're good
          if [ "$HEALTH_SUCCESS" = "true" ] && [ "$APP_SUCCESS" = "true" ]; then
            echo "âœ… Both health check and application are responding!"
            break
          fi
          
          # If at least one is working, continue with lighter checks
          if [ "$HEALTH_SUCCESS" = "true" ] || [ "$APP_SUCCESS" = "true" ]; then
            echo "â³ Partial success, continuing checks..."
          else
            echo "â³ No response yet, waiting..."
          fi
          
          if [ $i -eq 30 ]; then
            echo "âŒ Health checks did not pass after 30 attempts"
            
            # FIXED: Provide detailed debugging information
            echo "ğŸ” Debugging information:"
            echo "Load balancer DNS: $LOAD_BALANCER_DNS"
            
            # Test DNS resolution
            if nslookup "$LOAD_BALANCER_DNS" > /dev/null 2>&1; then
              echo "âœ… DNS resolution works"
            else
              echo "âŒ DNS resolution failed"
            fi
            
            # Test basic connectivity
            if ping -c 3 "$LOAD_BALANCER_DNS" > /dev/null 2>&1; then
              echo "âœ… Load balancer is reachable via ping"
            else
              echo "âŒ Load balancer is not reachable via ping"
            fi
            
            # Detailed HTTP test for health endpoint
            echo "Detailed health endpoint test:"
            curl -v -m 15 "http://$LOAD_BALANCER_DNS/health.php" 2>&1 || echo "Health endpoint test failed"
            
            # Detailed HTTP test for main app
            echo "Detailed main application test:"
            curl -v -m 15 "http://$LOAD_BALANCER_DNS/" 2>&1 || echo "Main application test failed"
            
            # Check load balancer target health
            echo "Checking load balancer target health..."
            LB_ARN=$(aws elbv2 describe-load-balancers --names "*proxy-lamp*" --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "unknown")
            if [ "$LB_ARN" != "unknown" ] && [ "$LB_ARN" != "None" ]; then
              TG_ARN=$(aws elbv2 describe-target-groups --load-balancer-arn "$LB_ARN" --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "unknown")
              if [ "$TG_ARN" != "unknown" ] && [ "$TG_ARN" != "None" ]; then
                echo "Target group health:"
                aws elbv2 describe-target-health --target-group-arn "$TG_ARN" --output table 2>/dev/null || echo "Could not get target health"
              fi
            fi
            
            # Don't fail the deployment if health checks are partial
            if [ "$HEALTH_SUCCESS" = "true" ] || [ "$APP_SUCCESS" = "true" ]; then
              echo "âš ï¸ Partial health check success - deployment considered successful"
              echo "ğŸŒ Try accessing: http://$LOAD_BALANCER_DNS"
              break
            else
              echo "âŒ Complete health check failure"
              exit 1
            fi
          else
            sleep 60  # FIXED: Wait 1 minute between attempts
          fi
        done
        
        echo ""
        echo "=== FINAL DEPLOYMENT STATUS ==="
        echo "ğŸŒ Application URL: http://$LOAD_BALANCER_DNS"
        echo "ğŸ” Health Check: http://$LOAD_BALANCER_DNS/health.php"
        echo "ğŸ“Š AWS Console: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}"
        echo ""
        
        # FIXED: Final verification with detailed status
        echo "=== FINAL VERIFICATION ==="
        
        # Test health endpoint one more time
        if curl -f -s -m 10 "http://$LOAD_BALANCER_DNS/health.php" > /tmp/final_health.json 2>/dev/null; then
          echo "âœ… Health endpoint final test: PASSED"
          if command -v jq >/dev/null 2>&1 && [ -f /tmp/final_health.json ]; then
            HEALTH_STATUS=$(jq -r '.status // "unknown"' /tmp/final_health.json 2>/dev/null || echo "unknown")
            SERVER_NAME=$(jq -r '.server // "unknown"' /tmp/final_health.json 2>/dev/null || echo "unknown")
            echo "   Status: $HEALTH_STATUS"
            echo "   Server: $SERVER_NAME"
            
            # Show database status
            DB_STATUS=$(jq -r '.checks.database.status // "unknown"' /tmp/final_health.json 2>/dev/null || echo "unknown")
            echo "   Database: $DB_STATUS"
          fi
        else
          echo "âš ï¸ Health endpoint final test: FAILED"
        fi
        
        # Test main application one more time
        if curl -f -s -m 10 "http://$LOAD_BALANCER_DNS/" > /dev/null 2>/dev/null; then
          echo "âœ… Main application final test: PASSED"
        else
          echo "âš ï¸ Main application final test: FAILED"
        fi
        
        echo ""
        echo "ğŸš€ Deployment completed!"
        echo "ğŸ“ Note: It may take a few more minutes for all health checks to stabilize"
        echo "ğŸ’¡ If you encounter issues, check the target group health in the AWS console"